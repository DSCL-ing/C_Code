define _CRT_SECURE_NO_WARNINGS 1

typedef int int;

//一、插入排序
//基本思想：
/*
直接插入排序是一种简单的插入排序法，其基本思想是：把待排序的记录按其关键码值的大小逐
个插入到一个已经排好序的有序序列中，直到所有的记录插入完为止，得到一个新的有序序列 。
实际中我们玩扑克牌时，就用了插入排序的思想

空							   n == 0	
摸第一张  ->   不用排    ->    n == 1
第二张    ->     排      ->    n == 2  (进入排序)  
n为牌数量
n == 1时 不用排
n == 2时 排1次
n == 3时 排两次
n == n时 排n-1次
   ···     ->    i < n-1 (循环条件i从0开始 ，n==1不用排，n==2开始排，一共排n-1次)

手牌顺序为[0 , end]   ，end+1 是准备插入的排 （想象手牌，0为第一张，end为最后） 
从一堆无序的牌中依次取牌排序 ， 排好后end从 0 增加到 n-1（end是下标，0就是第一张）

现在有[0 , end] 的牌，要放入end+1的牌 ，手要增加空间，增加空间，end+1还无序，需要排序插入，
排序的话前面数组可能要挪动，挪动就会覆盖值，有可能会把end+1覆盖掉，所以用tmp记住end+1的值，然后就能挪动了

（
脑中要有拿牌场景， 场景1：牌在桌子上，拿一张排一次序，目的是理解插入排序。
场景2 ：拿全部牌在手上，乱序，从前一张牌开始，即end==0开始，在[0,end+1]内排序，
[0 , end] 为有序，end+1为要插入的牌 。此场景符合数组排序情景。而场景一要把桌子上的
牌当作数组中未排序的，在有序子数组后面的一堆元素）
）
  1、
比较方法，拿牌一个一个去比较，从后往前依次比较，遇到比自己大的继续往前，遇到比
自己小的就停下，插在小的后面。如果到第一张也没有比自己小的，那就放在第一张前面
由此得循环条件end>=0,满足条件是a[end]<tmp/a[end]<=tmp,则插如a[end]后
(如果有相等的，a[end]<tmp 是插入在相同的前面，end的后面,a[end]是相同的前一个牌)
（			   a[end<=tmp 是插入在相同的后面，end为相同的牌)
  2、
有此基础后，实现时，我们可以每比较一次便往后挪一次，像程序软件打牌一样，从尾开始左
移动指针，指针后面的牌都会起立或后移 -- 代码： a[end+1] =a[end] //后移
  代码： 移动一次  end--  一次
  3、
  如果插入了，那就不要再走了，直接去排下一张牌，故要跳出这轮循环，进入下一轮循环。
  则代码： else break；

---，
*/

//1·直接插入排序
/*
直接插入排序的特性总结：
1. 元素集合越接近有序，直接插入排序算法的时间效率越高
2. 时间复杂度：O(N ^ 2)   ---  接近有序时非常快！
3. 空间复杂度：O(1)，它是一种稳定的排序算法
4. 稳定性：稳定*/


//插入排序核心
//n = 0 ，n =1 时不用排
//外层框架：从0开始，至少是2以上才进入循环，用for（int i =0; i < n-1; i++）实现
//开始情况：end = 0 ， 把[1]和[0]比较 ，插入或挪动 ， 结束循环
//中间情况：end = 0 ，... ，end = i ，把tmp]和[end]比较，插入或挪动 ，迭代下一个
//结束情况：end = n-2 , 把[n-1]和[n-1]比较，插入或挪动 ， 结束循环
void InsertSort(int *a , int n)
{
	for (int i = 0; i < n - 1; i++)
	{
		int end = i;
		int tmp = a[end + 1];  //记住要插入的（后面会被挪动覆盖）
		while (end>=0)
		{
			if (a[end] > tmp)  //升序
			{
				a[end + 1] = a[end];   //往后挪动
				end--;
			}
			else
			{
				break;
			}
		}
		a[end + 1] = tmp;//插入到指针的后一个
	}
}


//2·希尔排序（复习）   ------------是最常用的算法-----------------
//直接插入排序的基础上优化
//·先进行预排序，让数组接近有序
//·直接插入排序



//gap ==1 意思是差距为1(我和你相差一位/段) ， 即相邻  此时为直接插入排序
//gap ==2 意思是两数中间还有1个（相差两位/段），即n - m = 2 ，此时分为两组，
//第一个和第三个为一组，即差为2的为一组。
//gap == 3 意思是中间有2个，因为n - m = 3(相差三位/段)
//gap == n 则相差n-1位/段，我和从我开始的第n个为一组，end+gap即从end开始的第gap个（第一个为end+1）
/*
我和我的第n个为一组，那中间的每一个都是不同的组，即我和n-1组==n , 
gap等于几就有几组

那么gap有什么用呢？
可以发现gap越大，组成员的跨度越大 ，排序时组员能大幅度移动，
可以发现很大或很小的数能更快到达边缘位置，这是大的作用
而gap越小越接近直接插入排序，精度越来越高
所以，两者结合，gap合理地由大到小会加快插入排序的效率---希尔排序Shell's Sort
(gap != 1 时叫做预排序)
*/
void ShellSort(int *a, int n)
{
	int gap = n; //（gap不是固定的，也没有标准方法）
					//gap越大排完越不接近有序
						//大的数可以越快得到后面，小的数可以越快到前面
					//gap越小越接近有序
	while (gap > 1)
	{
		gap = gap / 2; //法一：优点：最终gap都能为1   -> log(2)n
		//gap = gap / 3 + 1;//法二：最后不一定为1（为0），需要辅助+1   ->log(3)n


		//gap很大时，下面预排序接近O(N)，数据量小
		//等到gap很小时 ，数组已经很接近有序了，所以下面排序也接近O(N)
		//故下面排序约为O(N)
		for (int i = 0; i < n - gap; i++)
		{
			int end = i;
			int tmp = a[end + gap];
			while (end >= 0)
			{
				if (a[end]>tmp)
				{
					a[end + gap] = a[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			a[end + gap] = tmp;
		}
	}
}

//总结下来：O(N) 约为 n * log(2)n 或 n *log(3)n .很快了，比指数慢快，比一次慢






//______________________________________________________________________________
//二、选择排序

//1、堆排序
//堆的物理结构是个数组 ， 通过下标确定父子节点关系
//leftchild = parent * 2 + 1;
//rightchild = parent * 2 + 1;
//parent = (child - 1) / 2;

//堆的两个特性 ：
//·结构性：用数组表示的完全二叉树
//·有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）
//		·大堆，大根堆，大顶堆（MaxHeap）
//		·小堆，小根堆，小顶堆（MaxHeap）
//大堆要求：树中所有的父亲都大于等于孩子
//小堆要求：树中所有的父亲都小于等于孩子

//向下调整算法:时间复杂度O(log2(N)):一次调整最多高度次
//从根节点开始,选出左右孩子中小的那个,跟父亲比较,如果比父亲小就交换,
//然后往下走,走到叶子节点就结束

//建堆 : 把数组排成堆  , 由于乱序，只能从从下往上调整->此过程称为建堆
//建一个堆的时间复杂度O(N)  ,为什么：要计算，错位相减
//·求和∑（n <= 高度 - 1）节点数 * 按层对应的节点向下调整的次数
//，然后错位相减，最终得到O(N) = n - log2(n+1) ≈ n;

//升序（大堆）
//·选出最大的数（根）与末元素交换，然后排除掉，不把它看作堆里面的，数组中属于堆的减1.
//·向下调整算法可以选出次大的，次大的换到倒数第二个位置，然后继续调堆，选出第三大··
//O(n + n*logN) = O(n(1 + logN)) = O(n*logN)   猜的


void Swap(int *p1, int * p2)
{
	int tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}

void AdjustDown(int *a, int n, int root)
{
	int parent = root;
	int child = parent * 2 + 1;
	while (child < n)
	{
		{
			if (child + 1 < n && a[child + 1] > a[child])
			{
				child += 1;
			}

			if (a[child] > a[parent])
			{
				Swap(&a[child], &a[parent]);
				parent = child;
				child = parent * 2 + 1;
			}
			else
			{
				break;
			}
		}
	}
}

void HeapSort(int *a, int n)
{
	//建堆
	for (int i = (n - 1 - 1) / 2; i >= 0; i--)
	{
		AdjustDown(a, n, i);
	}

	int end = n - 1;
	while (end > 0)
	{
		Swap(&a[0], &a[end]);
		AdjustDown(a, end, 0);
		end--;
	}
}



//2·直接选择排序
//select 美[sɪˈlekt]  选择; 选取; 挑选; 选拔

//时间复杂度还是O（n*n ），比一般的快一倍  
//算是最差的排序了，最好最坏都是n*n   ，最没用的

void SelectSort(int *a, int n)  //优化版
{ 
	int begin = 0, end = n - 1;
	while (begin < end)
	{
		int mini = begin, maxi = begin;//初始值随便给，在数组内都行
		//只是一个用于比较起点的值，找到更大或小的值就替换掉了
		for (int i = begin; i <= end; i++)
		{
			if (a[i] < a[mini])//下个i比mini是否更小
			{
				mini = i; //记下更小的下标，
			}
			if (a[i] > a[maxi])
			{
				maxi = i;
			}
		}
		//记下标要比直接交换快得多
		Swap(&a[begin], &a[mini]);
		if (begin == maxi)
		{
			maxi = mini;
		}
		Swap(&a[end], &a[maxi]);
		begin++;
		end--;

	}
}


//______________________________________________________________________________
//三、交换排序

//1·冒泡排序 (更惨)  //接近有序时比插入好点
bubbleSort(int* a, int n)
{
	for (int j = 0; j < n; j++)
	{
		int exchange = 0;  //监视哨
		for (int i = 1; i < n - j; i++)
		{
			if (a[i - 1] > a[i])
			{
				Swap(&a[i - 1], &a[i]);  //i > i+1 可能会越界，容易越界
				exchange = 1;
			}
		}
		if (exchange == 0)
		{
			break;
		}
	}
	//写法二
	//int end = n;     
	//while (end > 0)
	//{
	//	int exchange = 0;  //监视哨
	//	for (int i = 0; i < end; i++)
	//	{
	//		if (a[i - 1] > a[i])
	//		{
	//			Swap(&a[i - 1], &a[i]);
	//			exchange = 1;
	//		}
	//	}
	//	if (exchange == 1)
	//	{
	//		break;
	//	}
	//}
}




//2·快速排序  QuickSort 

有序时时间复杂度O(N), 乱序时时间复杂度O(n*log2(n));

特点：越乱越快
缺点：有序很慢
优化：三数取中



