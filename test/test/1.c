//记忆缓存区
//坑：算术运算，容易忽略算术转换
//
//记得算术转换  记得算术转换   记得算术转换   记得算术转换
//
//记得检查类型  记得检查类型  记得检查类型  记得检查类型
//
//知道类型才知算术转换  知道类型才知算术转换  知道类型才知算术转换
//知道类型才知算术转换  知道类型才知算术转换  知道类型才知算术转换
//strlen("abc") - strlen("abcdef") < 0 吗？，无符号减无符号得无符号 （size_t == unsigned int）

//assert不能使用在递归
//assert是个宏,只在debug存在,release中会被关闭

//perror <stdio.h> perror("hello");//hello：+错误信息

//static
//1.修饰局部变量，使全局，生命周期变化
//2.修饰全局变量，使限定于此文件，作用域改变，生命周期没变
//3.修饰函数
//递归的static会被跳过（不能再次初始化）---- 见树的遍历之计算节点个数
//局部的静态变量只能在局部访问，虽然它的生命周期是全局

//NULL：对空指针解引用操作->奔溃

//左花括号不换行好处
//1.通过右花括号快速找到if（抬头便是）。
//2.节省空间，紧凑
//换行好处：
//1.美观，大方


//若还警告scanf，则项目设置中关闭SDL检查
#define _CRT_SECURE_NO_WARNINGS 1
#define _CRT_SECURE_NO_DEPRECATE//getch
#define _CRT_NONSTDC_NO_DEPRECATE//getch
#include<math.h>

#include<stdio.h>//库函数标准
#include<string.h>
//#define MAX 10//定义常量(常量不可改动，自增自减的，没内存占用。预编译后不存在)
//定义没中大括号不用“;”
//直接全局定义#define XX 123
//strlen:求字符数组大小，以\0结束，即元素形式最后值为\0才能准确。字符串不用
#include<stdlib.h>//Sleep(1000)
#include<windows.h>//system("cls")
#include<conio.h>//控制台输入输出函数库 getch、

//#include"add.h"//自定义头文件用双引号""



//高内聚低耦合:强调函数功能高度集中，与其他函数少相通
//高内聚就是说相关度比较高的部分尽可能的集中,不要分散 
//低耦合就是说两个相关的模块尽可以能把依赖的部分降低到最小,不要让两个系统产生强依赖 
//1、问问自己有没有必要添加上这个功能（如返回值时打不打印，一般不要用）
//2、每个函数都要想着如何优化

//函数可以没有返回值和参数(如果没有定义形参，那么实参可以任意且对程序无影响)
//不想要实参参数则在形参内（void），传实参时会警告

//全局变量 - 不初始化默认是0；

//函数声明//自定义函数声明一般放在自定义头文件中
//int add(int, char);
//int main() { ; }
//int add(int x ,int y)

//形参在栈中保存
//放栈的特点，如局部变量进如作用域创建，离开作用域销毁。形参，进入函数创建，离开函数销毁。

//#ifndef __ADD_H__         // 如果未声明定义 add  就声明，否则返回假，跳过
//#define __ADD_H__
//int Add(int x, int y);    //函数声明
//#endif                    //声明结束


//任何数的模都小于模-1。

//错误、报错	2	error LNK1120 : 1 个无法解析的外部命令	C : \Users\26390\Desktop\vs2013\test1\Debug\text.exe	1
//解决，没改控制台
//不是所有控件都有返回值：有些地方缺少return，需要补全。







//局部变量以前一般省略auto（自动），自动的意思，即自动变量也叫局部变量（自动创建，自动消失）

//stdlib.h      exit(0);    //结束程序
exit(0) : 正常执行程序并退出程序。
exit(1)/exit(-1) : 非正常执行导致退出程序。
stdlib.h头文件中 定义了两个变量：
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1
所以等价; 0 == EXIT_SUCCESS; 1 == EXIT_FAILURE;
exit(EXIT_SUCCESS) : 代表安全退出。
exit(EXIT_FAILURE) ： 代表异常退出。

//stdlib.h	    system("pause");//暂停程序
//              pause通常在每个程序最后都会使用，用于使程序在关闭前停留确认。


//stdlib.h      Sleep（1111）;

//细节看操作符篇
//sizeof:计算的是变量/类型所占空间的大小。单位是字节。
//sizeof  操作数的类型长度（以字节为单位）
//sizeof  sizeof a 是标识符时能省略括号，但 sizeof int 是类型名时不可以
//(补充)  数组也是有类型，去掉数组名就是类型,变量名和数组名和类型大小是一样的，如int arr[10]={0};
//        printf("%d",sizeof(arr))     ;//40
//        printf("%d",sizeof(int [10]));//40
//        printf("%d",sizeof(int [ 5]));//20//数组的类型


//字符串：双引号内的字符串字面值，简称字符串“字面值abcd”
//字符串的结束标志：“\0”，且是隐藏的，实际值是“0”。字符串中不显示，不算作数组内容
//数组是一组相同类型元素的集合，从0开始。初始化就是给一些变量赋值
//int main()//主函数
//main有且仅有一个
//程序的入口
//
//int  整形 = 整数型
//
//
//{
//	char ch = '2';
//	printf("%c\n",ch);//print function=打印函数=printf(" ")=库函数（C语言本身提供的函数
//printf("a=%d\n b=%_d",a,b);//先打印a再打印b


//总结:根据格式来定义参数
//由格式决定参数
//比如%s，字符串格式，则对应的参数类型为字符串或字符数组
//如果参数跟随格式字符串，格式字符串必须包含确定参数输出格式的规范

printf(str); == printf("abcdef") == printf("%s", str);


//	//////库函数属于“别人”的→打招呼
//	stdio= 标准输入输出库= “standard input & output"
//	"\n"表示换行=即光标在下一行开头
//int main()
//{
//	int num1 = 10;
//	int num2 = 20;
//	int sum  = 0;
//	//scanf("%d%d", &num1, &num2);//输入函数，需要打字。直接计算不用scanf函数。
// &:对于本身已表示地址的类型，不用加取地址符
//	sum = num1 + num2;
//	printf("sum=%d\n",sum);
//	return 0;
//}
//
//
////自定义函数类比推广
////函数
////f(x)=y
////f(x,y)=x+y//多个自变量函数，自定义函数推广
//int Add(int x, int y)//对应f(x,y)=(xy)
//{
//	int z = x + y;
//	return z;
//}
//





//int main()
//{
//	int num1 = 0;
//	int num2 = 0;
//	int sum  = 0 ;
//	scanf("%d%d", &num1, &num2);
//	sum = Add(num1, num2);
//		printf("%d\n", sum);
//		return 0;
//}
//
//	int arr[MAX] = { 0 };
//	printf("%d\n", MAX);
//	}
//return 0;
//}
//
//
//
//字符串"abc"
//int main()
//{
//	char arr1[] = "abc";
//	//char arr2[] = { 'a', 'b', 'c' ,'\0'};
//	char arr2[] = { 'a', 'b', 'c' };
//	//printf("%s\n", arr1);
//	//printf("%s\n", arr2);
//	printf("%d\n", strlen(arr1));//strlen=3
//	printf("%d\n", strlen(arr2));//strlen=随机值
//	return 0;
//}
//
//
//
//
//
//	exturn int g_val;//声明函数
//	 
//	
//}
//const：修饰常变量（本质还是变量）→把常变量变成常量
//
//while循环语法示例
//int main()
//{
//	printf("好好学习，天天向上\n");
//	int line = 0;
//	while (line <= 20000)
//	{
//		printf("我要好好努力敲代码：%d\n",line);
//		line++;//i++意思是i=i+1
//	}
//	if (line > 20000)
//		printf("拿到好office\n");
//	return 0;
//
//
//
//int main()
//{
//	int arr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };//创建数组
//	//   数组下标   0  1  2  3  4  5  6  7  8   9
//	//所有数组的下标都是从0开始不可更改
//	printf("%d\n", arr[2]);//访问数组
//	int i = 0;
//	while (i < 9)
//	{
//		printf("%d,", arr[i]);
//		i++;
//	}
//	return 0;
////}
//

//int main()
//{
//	int a = 10;
//	printf("%p\n", &a);//%p为地址类型
//	int *p = &a;//指针变量，用来存放地址//*为解引用操作符
//	printf("%p\n", p);
//	printf("%d\n", *p);//值为10
//
//	char ch = 'w';
//	char *pc = &ch;
//	printf("%c\n",*pc );//%c为字符类型。/////////////////*p代表初始值，p内放的是地 址
//	*pc = 'a';
//	printf("%c\n", ch);
//	printf("%d\n", sizeof(pc));//////////////////////////故打印的是地址
//	return 0;
//}
///////////////////////////////系统位数，如32位            64位
							//即32根地址线\数据线         64根地址线\数据线
//{[][][]...32...[][][] - 0   }地址0                         以此类推，64位就是有64个比特位
//{[][][]...32...[][][] - 1	}地址1                         一个地址就占8个字节（32位一个地址占4个字节）
//{[][][]...32...[][][] - 2   }地址2
//...
//{[][][]...32...[][][]-2^32-1}地址2^32-1

//
//int main()
//{
//	int a = 0;
//	int b = 0;
//	if (a == 1)
//		printf("hehe\n");
//	else
//		printf("haha\n");
//
//	return 0;
//}

//
//int main()
//{
//	int a, b, c, max;
//	a = 10;
//	b = 5;
//	c = 1;
//	if (a > b&&a > c)
//
//		printf("A");
//	else
//		printf("B");
//	return 0;
//}

//________________________________________________________________________________________________________________________

//循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环
//循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环循环

//________________________________________________________________________________________________________________________
//

//确定循环的循环条件的两种方法
//1、有递增，递减，有头，有尾
//2、找规律，模拟过程，找到条件

//当（n）：n为非0常数，则恒为真，即永远满足条件
//举例：while（1）：则无限循环

//break，不仅适用于switch，同样适用while，优先级比while高！
//只要在循环中遇到break，就停止后期所有的循环。
//int main()
//{
//	int i = 1;
//
//	while (i <= 100)
//	{
//	
//		if (i % 2== 1)
//		printf("%d ", i); 
//		i = i + 1;
//	}
//		return 0;
//}


//switch-case语句
//switch (//整型表达式）//只识别整型
//case  整型“常量”表达式
//break:跳出switch语句
//default:不在范围则执行补充表达式(位置任意switch)
//int main()
//{
//	int day = 0;
//	scanf("%d", &day);
//	switch (day)
//	{
//	case 1:
//	case 2:
//	case 3:
//	case 4:
//	case 5:printf("工作日\n"); break;
//	case 6:
//	case 7:printf("休息日\n");break;
//	default:
//		printf("超出范围\n"); break;
//	}
//	return 0;
//	
//}

//int main()
//{
//	int i = 1;
//	while (i <= 10)
//	{
//		i++;
//		if (i == 5) 
//			continue;//continue是用于中止“本次”循环（注意是“本次”，还有下次循环），
//                   //也就是本次循环中continue后边的代码不会再执行，而是直接跳转循环语
//                   //句（while）的判断部分，进行"下一次"循环的入口判断。
//		printf("%d", i);
//	}
//}

//int main()
//{
//	int ch = 0;
//	while ((ch = getchar()) != EOF)//EOF:CTRL+L ,  end of file  =>  -1  //文件结束标志
//		putchar(ch);
//	return 0;
//}

//int main()
//{
//	int a = 1;
//	if (a = 0)
//		printf("%d", a);
//		if (a = 1)
//			printf("b");
//}

//输入缓冲区
//每次输入都会停留在此空间中，被相应函数提取相应数据后就没有了
//int main()
//{
//	int ret = 0, ch = 0;
//	char password[20] = { 0 };
//	printf("请输入密码:>");
//	scanf("%s", password);//password是数组，本身代表地址，不用取地址符&
//	                            //scanf只取走数组（数字），
//	printf("请确认(Y/N):>");   //          
//	                           //由于确认时使用了回车'\n'，故输入缓冲区中还有回车
//                               //接下来将会被getchar从输入缓冲区中提取	
//	                           //
//	
//	
//	while ((ch = getchar()) != '\n')     //此循环的作用就是提取掉输入缓冲区中多余字符
//	{                                   //没有的话getchar会提取'\n'等多余字符，导致直接输出
//		;
//	}
//	ret = getchar();
//	if (ret == 'Y')//单独的，未定义的，ascll码字符需要加''
//		printf("确认成功");
//	else
//	printf("放弃确认");
//
//	return 0;
//}


//for循环：表达式1为初始化部分；表达式2为条件判断部分；表达式3为调整部分；最后加上代码块，
//完成for循环。
//int main()
//{
//	int i=0;               //标准C语言i，j，k在for前定义，
//	for (i=1;i<=10 ;i++） //初始化位置-1   //判断位置-2   //调整位置4  //for内定义是c++语法
//	{                  
////		if (i == 5)
////			break;//printf= 1 2 3 4;     //表达式位置-3
//		printf("%d ", i);        
//
//
//	}                           
//	return 0;
//}


//2022/4/5
//计算文章单词数
//int main()
//{
//	int i, word=0,space =1;
//	char a[] = "i am a boy";
//	printf("%s\n", a);
//	for (i = 0; (a[i]) != '\0'; i++)
//	{
//		if (a[i] == ' ')
//			space = 1;
//		else if (space == 1)
//		{
//			word++;
//			space = 0;
//		}
//		else
//			space = 0;
//	}
//	printf("%d", word);
//	return 0;
//}

/***************************                                   冒泡排序

*/
//int main()
//{
//	int i, j, t, a[11];// = { 0, 25, 7, 3, 9, 11, 36, 14, 1, 6, 2 };
//	for (i = 1; i <= 10; i++)
//		scanf("%d", &a[i]);
//	for (i = 1; i <= 9; i++)
//		for (j = i + 1; j <= 10; j++)
//			if (a[i] < a[j])
//			{
//		t = a[i];
//		a[i] = a[j];
//		a[j] = t;
//			}
//	for (i = 1; i <= 10; i++)
//	{
//		printf("%d\t", a[i]);
//		if (5 == i)
//			printf("\n");
//	}
//	return 0;
//}


//
//int main()
//{
//	int price = 0;
//	printf("请输入金额（元）：");
//	scanf("%d", &price);
//	int change = 100 - price;
//	printf("找你%d元\n", change);
//	return 0;
//}
//
//

/*******************清屏，延时应用*******************************************************************/
//模拟动态启动加载动画
//int main()
//{
//
//	printf("请输入Y/y载入系统\n");
//	getchar();
//
//	printf("正在加载，请稍后.\n"); Sleep(1000);	system("cls");
//	printf("正在加载，请稍后..\n");	Sleep(1000); system("cls");
//	printf("正在加载，请稍后...\n"); Sleep(1000);	system("cls");
//	printf("正在加载，请稍后.\n");	Sleep(1000); system("cls");
//	printf("正在加载，请稍后..\n");	Sleep(1000); system("cls");
//	printf("正在加载，请稍后...\n");	Sleep(1000); system("cls");
//	printf("加载成功，正在载入\n");	Sleep(1000); system("cls");
//	char arr1[] = "                        ";
//	char arr2[] = "welcome to program world";
//
//	for (int left = 0, right = sizeof(arr1) / sizeof(arr1[0]) - 2; left <= right; left++, right--)
//	{
//
//
//		arr1[left] = arr2[left];
//		arr1[right] = arr2[right];
//		Sleep(500);
//		system("cls");
//		puts(arr1);
//
//		//printf("%s\n", arr1);
//	}
//	//printf("%s\n", arr1);
//	return 0;
//}


/*******************登录系统****************************/
//int main()
//{
//	int password[20] = { 0 };
//	scanf("%s", password);
//	if (strcmp(password, "123456") == 0)//不能直接比较字符串，“字符串不是C语言的基本类型,不能直接比较”
//		//必须使用strcmp
//	{
//		printf("登陆成功\n");
//	}
//	else
//	{
//		printf("密码错误，登陆失败\n");
//	}
//	return 0;
//}
//



/******            Binary_search     二分查找、折半查找        **********/
//int k = 6;
//int arr[] = { 1, 2, 3, 4, 5, 6, 9, 10, 11 };
//int main()
//{
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	int left = 0;
//	int right = sz - 1;
//
//	for (; left <= right;)
//	{
//		int mid = (left + right) / 2;
//		if (arr[mid] < k)
//			left = mid + 1;
//		else if (arr[mid] > k)
//			right = mid - 1;
//		else if (arr[mid] == k)
//		{
//			printf("找到了,下标为%d，值为%d。", mid, arr[mid]);
//			break;
//		}
//	}
//	if (right < left)
//		printf("找不到。");
//	return 0;
//}

// /*         Function Binary search  -   二分查找模块化        */
//#include<stdio.h>
//int binary_search(int arr[], int k, int sz)//
//{
//	int left = 0;
//	int right = sz - 1;
//	for (; left <= right;)
//	{
//		int mid = (left + right) / 2;
//		if (arr[mid] < k)
//			left = mid + 1;
//		else if (arr[mid] > k)
//			right = mid - 1;
//		else if (arr[mid] == k)
//		{
//			return mid;
//		}
//	}
//	return -1;//循环走完后没找到则返回-1
//}
//int main()
//{
//	int k = 6;
//	int arr[] = { 1, 2, 3, 4, 5, 6, 9, 10, 11 };
//	int sz = sizeof(arr) / sizeof(arr[0]);//sz放外头原因是形参数组只为首地址
//	int ret = binary_search(arr,k,sz);
//
//
//	if (-1==binary_search(arr,k,sz))
//		printf("找不到。");
//	else
//		printf("找到了,下标为%d，值为%d。", ret, arr[ret]);
//
//	return 0;
//
//}


/****************************************辗转相除法求最大公因数**********************************************/
/*                                       最大公倍数用短除法                                                 */
/************************************************************************************************************/
//#include<stdio.h>
//#include<math.h>
//int k1 = 24, k2 = 38;
//int a = 0;
//int b = 0;
//int y = 0;
//int beichu = 0, chushu = 0;
//
//int main()
//{
//	if (k1>k2)
//	{
//		a = k1;
//		b = k2;
//	}
//	else
//	{
//		a = k2;
//		b = k1;
//	}
//	beichu = a;
//	chushu = b;
//	printf("被除数为%d，除数为%d\n", a, b);
//	y = a%b;
//	printf("余数为%d\n", y);
//	for (; y != 0;)
//	{
//		beichu = chushu;
//		chushu = y;
//		y = beichu%chushu;
//		if (y == 0)
//			break;
//	}
//	printf("最大公因数为%d\n", chushu);
//}
//拓展优化：辗转相除的每一步试除都打印出来，直到余数为0时停止。



/*************************************************************计算闰年：
//                                     四年一闰，百年不润，而四百年又闰。*/
//int main()
//{
//	int year = 0;
//	int count = 0;
//	for (; year < 4000; year++)
//	{
//		if ((year % 4 == 0) && (year % 100 != 0))
//		{
//			count++;
//			printf("%d\t", year);
//		}
//		else if(year%400==0)//但是==或
//		{
//			count++;
//			printf("%d\t", year);
//		}
//		//if (((year % 4 == 0)  &&  (year % 100 != 0)) || (year % 400 == 0))
//		//{
//		//	count++;
//		//	printf("%d\t", year);
//
//		//}
//		if (count % 5 == 0)
//			printf("\n");
//	}
//	printf("count=%d", count);
//	return 0;
//}
//





/****************************                 试除法求素数                               **********/
//int main()
//{
//	int i = 0;
//	int count = 0;
//	for (i = 100; i <= 200; i++)//代码优化，i=a*b;由数学得，a和b至少有一个数字《=开平方i；（a和b!=i）
//	{                           //16=2*8=4*4；
//		int j = 0;              //而找到一个因数，就不需要再找另一个因数，故只需到sqrt（a/b）；
//		for (j = 2; j < i; j++) //再优化，有数学得，最小非素数为4，只要i》=4时，f(i)>=sqrt(i)即可，显然i/2满足条件;
//		{
//			if (i%j == 0)
//			{
//				break;
//			}
//
//		}
//		if (i == j)
//		{
//			count++; printf("%d\t", i);
//		}
//	}
//	printf("素数个数为%d", count);
//	return 0;
//}
/*                                           优化代码如下                                   */
//#include<stdio.h>
//#include<math.h>
//int main()
//{
//	int i = 0;
//	int count = 0;
//	for (i = 100; i <= 200; i++)//代码优化，i=a*b;由数学得，a和b至少有一个数字《=开平方i；（a和b!=i）
//	{                           //16=2*8=4*4；
//		int j = 0;              //而找到一个因数，就不需要再找另一个因数，故只需到sqrt（a/b）；
//		for (j = 2; j <i / 2; j++) //再优化，有数学得，最小非素数为4，只要i》=4时，f(i)>=sqrt(i)即可，显然i/2满足条件;
//		{
//			if (i%j == 0)
//			{
//				break;
//			}
//
//		}
//		if (j == i / 2)
//		{
//			count++; printf("%d\t", i);
//		}
//	}
//	printf("素数个数为%d", count);
//	return 0;
//}


//**************************************             求0到100中含9的数字的个数             */
//int main()//缺陷，仅正数
//{
//	int i = 0;s
//	int count = 0;
//	for (i = 0; i <= 100; i++)//原理：(一)n9:9,19,...99；（二）9n：90，91，...98。总计19
//	{
//		if (i % 10 == 9);//条件一//模进位数能用来找数，一个数的个位数
//		if (i / 10 == 9);//条件二//除进位数能右移，得到去掉个位的数//右移位操作符
//		//有重复，所以减重复，即减一
//			{
//
//			}
//	}
//}


/**********************            九九乘法表上三角                                            */
//int main()
//{                                           //制表符妙用：自动填充空格，自动对齐；
//	int i = 0, j = 0, y = 0;                  //其他情况，用%-n,md填充空格
//	for (i = 1; i <= 9; i++)
//		for (j = i; j <= 9;j++)
//	{
//		y = i*j;
//		printf("%d*%d=%d\t", i, j, y);
//		if (j == 9)
//			printf("\n");
//	}
//	return 0;
//}

/**********************            九九乘法表下三角                                            */
//int main()
//{
//	int i = 0, j = 0, y = 0;
//	for (i=1;i<=9;i++)
//		for (j=1;j<=i;j++)
//	{
//		y = i*j;
//		printf("%d*%d=%d\t", i, j, y);
//		if (i == j)
//		printf("\n");
//	}
//	return 0;
//}




//****************                           猜数字游戏                          *********************/
//#include <time.h>
//#include<stdlib.h>
//#include <stdio.h> 
//#include<windows.h>
//
////RAND_MAX// -    转到定义查看数值-32767
////time_t         -转到定义查看最终返回值类型 (_time32为long)（_time64为int）:故直接对time强制类型转换unsinged int
//void menu()
//{
//	void game();
//	int input = 0;
//	do
//	{
//		
//		printf("**********************************************************\n");
//		printf("****  1.玩游戏                                       *****\n");
//		printf("****  2.退出游戏                                     *****\n");
//		printf("**********************************************************\n");
//		scanf("%d", &input);
//		if (input == 1)
//		{
//			system("cls");
//			game(); 
//		}
//		else if (input == 2)
//				break;
//		else
//		{
//			printf("输入有误，请重新输入！"); 
//		}
//		
//	}
//		while (1);
//	
//
//}
//
//void game()
//{
//	int input = 0;
//	int guess = 0;
//	int num = 0;
//	num = rand()%100+1;
//	//printf("%d\n", num);
//	do
//	{
//		printf("请输入数字（1-100），按回车键确认\n");
//		scanf("%d", &guess);
//		if (guess > num)
//			printf("猜大\n");
//		if (guess < num)
//			printf("猜小了\n");
//		if (guess == num)
//		{
//			printf("猜中了\n"); 
//			printf("1.continue                              2.exit\n");
//			scanf("%d", &input);
//			if (input == 1)
//			{
//				system("cls");
//				game();
//			}
//			else if (input == 2)
//				break;
//			else
//			{
//				printf("输入有误，请重新输入！");
//			}
//		}
//	} while (1);
//	
//}
//
//
//int main()
//{
//	void game();
//	void menu();
//	
//
//	/*          时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)
//	 * 起至现在的总秒数。                                   
//	Unix时间戳(Unix timestamp)，或称Unix时间(Unix time)、POSIX时间(POSIX time)
//	*/
//	srand((unsigned int)time(NULL));// 只需设置一次，数表一次起点后数字差异足够大
//<stdlib.h> srand()
//	
//	menu();
//
//	return 0;
//}

/*                           goto 语句使用规则                              */
//#include<stdio.h>
//int main()
//{
//again:
//	printf("hehe\n");
//	goto again;
//	return 0;
//}
// goto合适使用场景：多层循环，深层嵌套；//便利。break只能跳一个。goto能直接到达
/* for (;;)
*       for (;;)
*           for (;;)
*                {
* 	              if (disaster)
* 		             goto error;
*                 }
* error:if (disaster)
*    //处理错误
* /

// /*                            开、关机命令与程序                    */
//#include<stdio.h>
//#include<windows.h>
//#include<string.h>
////#define char(A) 86400
//int main()
//{
//	char input[20] = { 0 };
//	//shutdown -s -t 60;//“-S”是关闭的意思。“ - t" 是时间(秒)的意思。-a是取消关机的意思；
//	//shutdown - s - t 600   600秒后电脑关机。
//	//system()-执行系统命令
//	//cmd（command-命令行）
//	while (1)
//	{
//		printf("请输入“关机”进行关机");
//		scanf("%s", input);
//		if (strcmp(input, "关机") == 0)//strcmp()比较两个字符串；
//		{
//			//char A[] = "123456789"; 
//			//char B[] = "60";
//			//strcpy(A, B);
//			//printf("%s", A);
//			system("shutdown -s -t 600");
//
//		}
//		else
//		{
//			printf("取消关机");
//			system("shutdown -a"); break;
//		}
//	}
//	return 0;
//}//拓展：运用str复制等函数实现定时关机程序//需要宏，还没学



// /*                    Function memset  example              */
//#include<stdio.h>
//#include<string.h>
//int main()
//{
//	char arr[] = "hello world";
//	printf("%s\n", arr);
//	memset(arr, '*', 5);
//	printf("%s\n", arr);
//	return 0;
//}


// /*      形参和实参-形参元素-值与地址区别                */
//void Swap1(int x, int y)//传值调用 ：要在栈区开辟与实参相同的大小的空间
//{                          //归纳，普通型int   a; fun(a);
//	int tmp = 0;             //      指针型int*str; fun(str);//容易出错
//	tmp = x;                 传的是本身：
//	x = y;
//	y = tmp;
//}
//
//void Swap2(int* pa, int* pb)//传址调用  ：仅开辟形参大小的空间，直接访问实参数据，无需开辟
//{                           //归纳，普通型int   a; fun(&a);
//	int tmp= 0 ;              //      指针型int*str; fun(&str);//容易出错
//	tmp = *pa;                传的是本身的地址，指针也要传指针的指针
//	*pa = *pb;
//	*pb = tmp;
//}
//
//int main()
//{
//	int a = 10, b = 20;
//	Swap1(a, b);
//	printf("a=%d,b=%d", a, b);//a,b值不变
//	Swap2(&a, &b);
//	printf("a=%d,b=%d", a, b);//a,b值交换
//	return 0;
//}
//形参其实是实参的一份拷贝，修改不会改变实参，对形参的修改是不会改变实参的！
//传值调用时会开辟空间，时间空间会浪费
//未调用时不占空间，调用时才会开辟空间
//传值调用的好处是是被调函数不会改变调用函数传过来的值, 可以放心修改
//传值调用时，参数是需要压栈的。如果传递一个结构体对象时结构体过大，参数压栈的系统开销比较大，
//会导致性能下降

//函数间的数据传递可以用全局变量


//递归的两个必要条件
//1、存在限制条件，当满足这个限制条件的时候，递归便不再继续。
//2、每次递归调用之后越来越接近这个限制条件。
//递归的思想：盒中盒子，有逐层的，依次的结构，。
//（考察）：不创建临时变量实现xxx
//递归中不能使用assert


// 任何一次函数调用，都会向内存申请空间
/* c语言中内存简单分为栈区、堆区、静态区。
* 栈区：局部变量开辟空间、函数形参开辟空间、函数调用开辟空间
* 堆区：动态开辟的内存，如malloc/free、realloc、calloc
* 静态区：全局变量、static修饰的变量(静态变量)
//栈的内存开辟是从高地址往低地址段开辟,但是读取内存都是从低地址往高地址读取的

---------------------先分配（开辟空间）再使用（元素分配）------------------
创建变量（开辟空间），在高地址开辟空间。下一个变量，在地址处开辟空间

元素分配，在已开辟好的空间范围内先填低地址再填高地址

如数组，在已使用的高地址下面的低地址处开辟相应大小的空间，
分配元素时，在已开辟好的空间内，先填低地址，再填高地址

//Stack overflow 递归常见错误，栈溢出。//即栈空间一定，每次申请一部分，
//满了之后就会溢出，然后报错

//return 只能返回一个数据

//TDD 测试驱动开发，先写主函数框架，确定函数功能，再分别写函数


/*                  自定义求字符串长度函数                */
//#include<stdio.h>
//int my_strlen(char arr[])              //循环计数器法strlen
//{
//	int count=0;
//	
//	while (*arr != '\0')
//	{
//		count++;
//		*arr++;
//	}
//	return count;
//}
//
//int main()
//{
//	char arr[] = "aaaaaaaa";
//	printf("%d", my_strlen(arr));//TDD测试驱动开发
//}

// /**************       无临时变量求字符串长度(递归)                       */
//#include<stdio.h>
//int my_strlen(char arr[])           //递归法求strlen
//{
//	if (*arr != '\0')
//	{
//		return 1 + my_strlen(arr+1);
//	}
//	else
//		return 0;
//}
//int main()
//{
//	char arr[] = "aaaaaaaa";
//	printf("%d\n", my_strlen(arr));
//	return 0;
//}


//递归与迭代（都与循环类似）（数学概念）
//递归(拆盒子)：从后往前，并不断趋近答案//可能出现 “栈溢出” stack overflow
//(F1大条件默认在主调函数，为真)
//			  -> else 0 
//       F1= |               =>      F2=...
//			 |-> 1
// 			  -> if(...)F2 
//迭代(叠盒子)：从前往后，并不断趋近答案

/*******************           求阶乘（递归）                   */
//#include<stdio.h>
//#include<stdlib.h>
//int fac1(int n)//递归
//{
//
//	if (n > 1)
//	{
//		return n*fac1(n - 1);
//	}
//	else if (n == 1 || 0)
//	{
//		return 1;
//
//	}
//	else
//	{
//		printf("输入有误\n");
//		exit(0);
//	}
//}
//int fac2(int n)//迭代
//{
//	int ret = 1;
//	for (int i = 1; i <=n; i++)
//	{
//		ret = i*ret;
//	}
//	return ret;
//}
//int main()
//{
//	int n = 0;
//	printf("请输入所求阶乘数，按回车键结束\n");
//	scanf("%d", &n);
//	printf("结果为%d\n", fac1(n));
//	printf("结果为%d\n", fac2(n));
//	return 0;
//}

/************			 比较递归与迭代两种方法求斐波那契数列             */
//斐波那契数列
//1 1 2 3 5 8 13 21 34 55 ...
//#include<stdio.h>
//int Fib1(int n)//递归,算法缺陷，出现超多次重复计算，浪费算力，n=50时要算10分钟
//{
//
//	if (n>2)
//		return Fib1(n - 1) + Fib1(n - 2);
//	if (n = 1 || 2)
//		return 1;
//}
//long int Fib2(int n)//迭代，辗转相除思路，计算更快，可以发现，同样问题,好的算法效率更高
//{
//	long int a = 1, b = 1, c = 1;
//	while (n > 2)//大到小自减，小到大要引i//for可以避免此类问题，较为中规中矩
//	{
//		c = a + b;//可以回头去优化辗转相除
//		a = b;
//		b = c;
//		n--;
//	}
//	return c;
//}
//int main()//TDD测试驱动开发，先框架，再编代码
//{
//	long int ret = 0;
//	printf("请输入所求斐波那契数的项数,按回车键结束\n");
//	scanf("%d", &ret);
//	//printf("%ld\n", Fib1(ret));
//	printf("%llu\n", Fib2(ret));
//
//	return 0;
//}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//数组的创建方式
//type_t arr_name [const_n];
//type_t 是指数组的元素类型 int char float double
//const_n 是一个常量表达式，用来指定数组的大小
//[必须是常量]，[n]不行

//数组名表示整个数组地址的两个情况，其余情况为首元素地址
//1、sizeof(arr)    2、&arr 取出的是整个数组的地址
//举例如下
//#include<stdio.h>
//int main()
//{
//	int arr[] = { 1, 2, 3, 4 };
//	printf("%p\n", arr);
//	printf("%p\n", arr + 1);//平移了一个元素的长度
//
//	printf("%p\n", &arr[0]);
//	printf("%p\n", &arr[0] + 1);//平移了一个元素的长度
//
//	printf("%p\n", &arr);
//	printf("%p\n", &arr + 1);//平移了整个数组的长度
//	return 0;
//}

//strlen 只能针对字符串求长度，                 库函数
//sizeof 计算变量、数组、类型大小，单位是字节 - 操作符

//char arr1[] = "abc";
//char arr2[] = { 'a', 'b', 'c' };
//printf("%d\n", sizeof(arr1[]));//4
//printf("%d\n", sizeof(arr2[]));//3
//printf("%d\n", strlen(arr1[]));//3
//printf("%d\n", strlen(arr2[]));//随机值，因为arr只占3字节，后面其他空间的地址指向的不一定是\0；只有到\0才停止

//地址存放：连续，十六进制，低地址到高地址


//代码优化 从减少浪费，无用过程下手



/********                      bubble_sort —— 冒泡排序              */
//#include<stdio.h>
//void Swap(int* pa, int* pb)
//{
//	int tmp;
//	tmp = *pb;
//	*pb = *pa;
//	*pa = tmp;
//}
//void bubble_sort(int *arr, int sz)
//{
//	int flag = 1;//优化，有序后终止循环
//	int tmp = 0;
//	for (int i = 0; i < sz - 1; i++)
//	{
//		for (int j = 0; j < sz - 1 - i; j++)
//			if (arr[j] > arr[j + 1])//  '<' 降序; '>' 升序
//				不太有逻辑，实际就是j和j+1项在移动
//			{
//			Swap(&arr[j], &arr[j + 1]);
//			flag = 0;//只要发生交换
//			}
//		if (flag == 1)//只要有一轮不发生交换
//			break;
//	}
//}
//
//int main()
//{
//	int arr[] = { 7, 5, 1, 9, 2, 3, 8, 4, 0, 6 };
//	int sz = sizeof(arr) / sizeof(arr[0]);
//	bubble_sort(arr, sz);
//	for (int i = 0; i <sz; i++)
//	{
//		printf("%d   ", arr[i]);//遍历
//	}
//	return	0;
//}

//_____________________________________________________________________________________
//                        数制（进制）
//基数:即“逢n进一”，其中n被称为技术。数制的进位所遵循的规则，
//位权：10^n叫位权（简称权）。第几位的位权...
//  对于多位数，处在某一位上的“1”所表示的数值的大小，称为该位的位权。
//    例如十进制第2位的位权为10，第3位的位权为100；而二进制第2位的位权为2，第3位的位权为4，
//       对于 N进制数，整数部分第 i位的位权为N^(i-1)，而小数部分第j位的位权为N^-j。
//(i,j 都是从1开始的数)

//0.5(d) == 0.1(b) :位权1/2   即1*1/2

//科学计数法 0.1 == 1.0*n^-1 ; 如0.1（b） == 1.0*2^-1

/*********                                     操作符                    ********/
/*********                                     操作符                    ********/
/*********                                     操作符                    ********/

//对于/操作符，如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。
//%操作符的两个操作数必须为整数。返回的是整除之后的余数。
//除了%操作符之外其他的几个操作符可以作用于整数和浮点数，看1/

/*    移位操作符（补码操作）

//右移操作符 ‘>>k’
//：向右移动k个二进制位，右移一次就少一个位权，相当于除以二
//其中分为“算数右移”和“逻辑右移”
//通常为“算数右移”。规则，右边丢弃，左边补原符号位。
//逻辑右移规则为：右边丢弃，左边补零

//左移操作符‘<<’：左边丢弃，右边补零
//有×2效果

//警告：对于移位操作符，不要移动负数位，这个标准是未定义的。未定义警告。如  >> -1
//只能作用于整数，不能作用在浮点数
*/    

//反码
//反码的表示方法是:
//1.正数的反码是其本身
//2.负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

//补码
//补码的表示方法是 :
//正数的补码就是其本身
//负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 + 1. (即在反码的基础上 + 1)
//计算机存放的是补码
//正数没有反码和补码，只有按位取反
//反码和补码是为负数服务的，用于表示计算机中的负数

//总结
//在知道一个数原码的情况下 :
//正数：反码，补码 就是本身自己
//负数：反码是高位符号位不变，其余位取反。补码：反码 + 1

/*    （二进制位操作符）位操作符
//&（按位与操作符），按二进制位与
//；两个二进制位比较，都为一则一（一一得一），否则为0；

//‘||’（按位或操作符），按二进制或
///两个二进制位比较，只要有一个是一则一（有一得一），否则为0；

//‘^’（按位异或操作符）
相同为0，不同为1。

0异或任何数为任何数
本身异或本身为0
*/

// /************      不创建临时变量交换两个变量的值(异或举例)        */
//
//int main()//法一，加减法——类比，刻度。
//          //有缺陷，有范围，范围有由变量类型决定，加起来如果超出后会失效
//{
//	int a = 3;//有3刻度
//	int b = 5;//有5刻度
//	a = a + b;//利用刻度3和刻度5，变3为8消3
//	b = a - b;//利用刻度8-刻度5，变5为3消5，
//	a = a - b;//利用刻度8和5，变8为3消8.
//	return 0;
//}
//

//int main()//法二，异或法
////异或原理：两数异或后产生的中间变量再与其中一数异或后得到另一数值
//{
//	int a = 3;
//	int b = 5;
//	a = a^b;
//	b = a^b;
//	a = a^b;
//	return 0;
//}

//打印数的二进制各个奇数位和偶数位（按位与）
//void Print(int num)
//{
//	printf("奇数位\n");
//	for (int i = 30; i >= 0; i -= 2)
//	{
//		printf("%d ", (num >> i) & 1);   //右移几位就干掉几位，剩n-i位
//	}
//	printf("\n");
//	printf("偶数位\n");
//	for (int i = 31; i >= 0; i -= 2)
//	{
//		printf("%d ", (num >> i) & 1);
//	}
//}
//
//int main()
//{
//	int num = 0;
//	scanf("%d", &num);
//	Print(num);
//	return 0;
//}


/****************      输入一个数求二进制补码中1的个数                     ***************/
//int main()//法一，十进制法
//          //有缺陷，首先有负数不行，其次范围//补救
//{
//		int num = 0;
//		int count = 0;
//		printf("请输入要求二进制中1的个数的数\n");
//		scanf("%d", &num);
//		while (num)                   //补救，while(（unsigned int）num)
//		{
//			if (num % 2 == 1)
//			{
//				count++;
//			}
//			num /= 2;
//		}
//		printf("%d", count);
//	return 0;
//}

//int main()//法二，二进制操作法(还不会用)
//{
//	int num = 0;
//	int count = 0;
//	printf("请输入要求二进制中1的个数的数\n");
//	scanf("%d", &num);
//	for (int i = 0; i < 32; i++)
//	{
//		if (1 == (num >> i & 1))
//		{
//			count++;
//		}
//	}
//	printf("%d", count);
//	return 0;
//}

//法三：数学规律技巧
//int count_bit_one()               //count（统计）  one（个数） get(获取)
//{
//	int count = 0;
//	while (n)
//	{
//		n = n&(n - 1);
//		count++;
//	}
//	return count;
//n=n&(n-1)
//n = 13
//1101  n
//1100  n-1
//1100  n=n&(n-1)
//1011  n-1
//1000  n = n&(n-1)
//0111  n-1
//0000  n = n&(n-1)
//}




//计算两数中不同位的个数
//int get_diff_bit(int n, int m)          //diff  ==  different (差异，不同的)
//{
//	int tmp = n^m;
//	int count = count_bit_one(tmp);//在统计二进制中1的个数
//	return count;
//}
//
//int main()
//{
//	int m = 0, n = 0;
//	scanf("%d%d", &m, &n);
//	int count = get_diff_bit(n, m);
//	printf("count = %d\n", count);
//	return 0;
//}


//_____________________________________________________________________________________
//单目操作符（10个）

//  “  ！ ”   （逻辑反操作）：真变假，假变真
//若a=999，则!a=0;若a=0，则a=1。

//   “-”，“+”， “++”，“--”，“（类型）”

// &a “&”  取地址操作符，
// *p “*”  解引用操作符：通过p里面的值，找到p所指向的对象*p


//sizeof  操作数的类型长度（以字节为单位）
//sizeof  sizeof a 是标识符时能省略括号，但 sizeof int 是类型名时不可以
//(补充)  数组也是有类型，去掉数组名就是类型,变量名和数组名和类型大小是一样的，如int arr[10]={0};
//        printf("%d",sizeof(arr))     ;//40
//        printf("%d",sizeof(int [10]));//40
//        printf("%d",sizeof(int [ 5]));//20//数组的类型

//sizeof  形参接收数组使用指针变量的，接收数组首地址，故大小为4或8（由系统位数决定）

//sizeof  括号内运算不会影响括号外  ，作用域就括号内，运算完就没了，不会参与运算
//int main()
//{
//	short s = 0;
//	int a = 10;
//	printf("%d", sizeof(s = a + 5);//值为2
//	printf("%d",        s        );//值为0，原因，sizeof()内运算不会真实运算，不会影响实际空间
//}

//sizeof  计算变量/类型所占内存的大小一定是>= 0的，所以是无符号数（算术转化）
int i;          //全局变量，不初始化默认为0；
int main()
{
	i--;               //i为-1
	if (i > sizeof(i)) //
		printf(">\n"); //结果打印>
	else
		printf("<\n");
	return 0;
	//整型遇到无符号整型，算术转换，-1变无符号后，非常大
}

//  " ~ "   ：对二进制的每一位，原值为1的变为0；原值为0的变为1
//#include<stdio.h>
//int main()
//{
//	int a = 0;
//	//机器流程
//	1、0000000000000000000000 - 补码（0的补码）(原反补一样)（机器内的）
//		2、1111111111111111111111 - 补码（ - 1的补码)（按位取反得到的）（机器内的）
//		3、1111111111111111111110 - 反码（补码 - 1即为反码）
//		4、1000000000000000000001 - 原码（给人看的）
//		printf("%d", ~a);
//	return 0;
//}

//_____________________________________________________________________________________
//关系操作符(一共6个)
//   ">"  , ">="  , "<"  , "<="  , "!="  , "=="


//_____________________________________________________________________________________
//逻辑操作符
//  "&&"  ,  "||"
//  "||"  : 只要左边是真，后面就不计算了
//  "&&"  : 只要左边是假，后面就不计算了


//_____________________________________________________________________________________
//三目操作符  -  条件操作符(  exp1 ? exp2 :exp 3   )
/*
 * if (exp1)
 *     exp2;
 * else
 *     exp3 ;
 */

//_____________________________________________________________________________________
//逗号表达式 （ exp1 , exp2 , exp3 , ... ,expN )
//逗号表达式的优先级是比赋值=的优先级低的！！！！！！！！！！！！！！！！！
//逗号表达式中的后置++和前置一样，如 a=1,b=a++,++a;//b=3
//逗号表达式，就是用逗号隔开的多个表达式。逗号表达式，从左向右依次进行，整个表达式的结果
//    是最后一个表达式的结果。
//exp1: if(a=b+1,c=a/2,d>0)  //起作用的只有 d > 0 ,a=b+1也是有运算的，只是不影响if
//exp2: 函数exec((v1,v2),(v3,v4),v5,v6)中参数有（4）个。
//逗号表达式（v1,v2）最终值为v2，（v3，v4）最终值为v4   //值为最后一个的结果
//exp3: 
/* a=get_val();
 * count_val(a);
 * while(a>0)
 * {
 *     a=get_val();
 *     count_val(a);
 * }
 */
//如果使用逗号表达式，改写为：
/* while( a=get_val() , count_val(a) , a > 0)
 * {
 * 	;
 * }
 */




//_____________________________________________________________________________________
//下标引用、函数调用和结构成员

//   “ [ ] ”  下标引用操作符
//   操作数 ： 一个数组名 + 一个索引值
//如  int arr[10] ;
//    arr[9] = 10 ;
//    [ ] 的两个操作数是arr和9.   （ 1 + 2 ， “ + ” 的两个操作数为1和2）
//    arr是数组名。9是索引值

//    " ( ) "   函数调用操作符
//    有一个或多个操作数，第一个操作数是函数名，剩余的操作数就是传递给函数的参数。
//    调用函数的 " ( ) " 才是函数调用操作符，定义函数的 " ( ) " 不是函数调用操作符，那是语法规则。
//    如
//    int max = get_max(a , b); 第一个操作数是函数名get_max,第二是a，第三是b

//    “ . ” , “ -> ”结构体成员运算符
//     .      结构体.成员名
//     ->     结构体指针->成员名

/* struct stu
 * {
 * 	char name[10];
 * 	int age;
 * 	char sex[5];
 * 	double score;
 * };
 *
 * int main()
 * {
 * 	struct stu s1;
 * 	struct stu *ps = &s1;
 * }

 * exp1（常规）
 * printf("%d", s1.name);
 * printf("%d", s1.age);

 * exp2（指针）
 * printf("%d", (*ps).name);
 * printf("%d", (*ps).age);

 * exp3(为方便而化简)
 * printf("%d", ps->name);
 * printf("%d", ps->age);
 */

//_____________________________________________________________________________________
//表达式求值：
//表达式求值的顺序一部分是由操作符的优先级和结合性决定，同样，有些表达式的操作数在求值的过程中可能需要转换成其他类型

//1、隐式类型转换（整型提升）：偷偷地进行类型转换
//整型提升的意义
/* 表达式的整型运算要在ＣＰＵ的相应运算器件内执行，ＣＰＵ内整型运算器（ＡＬＵ）的操作数
 * 的字节长度一般就是ｉｎｔ　的字节长度，同时也是ＣＰＵ的通用寄存器的长度。
 * 因此，即使两个ｃｈａｒ类型相加，在CPU执行时实际上要先转换为CPU内整型操作数的标准长度
 * 通用CPU时难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。
 * 所以，表达式中各种长度可能小于int长度的整型值都必须先转换成int或unsigned int ,然后才能
 * 送进CPU去执行运算。

 * C的整型算术运算总是至少以缺省整型类型的精度来进行的。
 * 为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，
 * 这种转换称为整型提升。
 */

//提升的方法(补码层面操作)
//提升只看原类型，是有符号补原符号，无符号补0
//从符号位开始插入，插入的数与符号位一致（无符号补0）
//只要参与表达式运算, 就会发生整形提升,
//int main()
//{
//	char a = 3; char b = 127; char c = a + b;
	//00000011     01111111         求和时需要以cpu运算器ALO的操作数的字节int运算，要变成int。
	//0|0000011    0|1111111     （从符号位开始插入，插入符号位，补码（==原码）操作）
	//00000000000000000000000000000011      +    00000000000000000000000001111111==
	//00000000000000000000000010000010      ==   128+2==130 (没有截断前)
	//                        10000010   （“补码”直接末尾截断）
//	printf("%d", c);        //(打印整型数据，则进行提升)
	//                        1|0000010  (补码)
	//1111111111111111111111111 0000010  (补充的是符号位)
	//1111111111111111111111111 0000001  (反码)
	//1000000000000000000000000 1111110  (原码：反码符号位不变，其他按位取反） ==  -126
//	return 0;
//}

//整形提升的例子:
////实例1
//int main()
//{
//	char a = 0xb6;       //    10110110
//	short b = 0xb600;    //    1011011000000000
//	int c = 0xb6000000;  //    10110110000000000000000000000000
//	if (a == 0xb6)       //a不是int，要整型提升，a==1|11111...11111|0110110 !=10110110
//		printf("a");     //不等，所以不打印
//	if (b == 0xb600)     //同理，b不是int，要整型提升，长度为32字节，b600只有16字节。
//		printf("b");     //不打印
//	if (c == 0xb6000000) //c是整型，不用整型提升，且同为32字节。
//		printf("c");     //打印
//	return 0;
//}

//实例2
//int main()
//{
//	char c = 1;
//	printf("%u\n", sizeof(c));
//	printf("%u\n", sizeof(+c));
//	printf("%u\n", sizeof(-c));
//	return 0;
//}实例2中的,c只要参与表达式运算,就会发生整形提升,表达式 +c ,就会发生提升,所以 sizeof(+c) 是4个字
//节.
//表达式 - c 也会发生整形提升, 所以 sizeof(-c) 是4个字节, sizeof(c)是1个字节.


//2. 算术转换
//如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类
//型，否则操作就无法进行。下面的层次体系称为寻常算术转换。
//
//排名表
//long double
//double
//float
//unsigned long int
//long int
//unsigned int
//int
//
//如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运
//算。
//
//警告：
//但是算术转换要合理，要不然会有一些潜在的问题。
//float f = 3.14;
//int num = f;//隐式转换，会有精度丢失

//3 操作符的属性
//复杂表达式的求值有三个影响的因素。
//1. 操作符的优先级
//2. 操作符的结合性
//3. 是否控制求值顺序。
//两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。
//操作符优先级
//
//问题表达式：我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题
//的。如i++---i什么的，题目有病



//_____________________________________________________________________________________
//指针
//指针就是地址，口语中说的指针通常指的是指针变量。
//指针变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理）。
/*那这里的问题是：

//一个小的单元到底是多大?（1个字节）
 * 经过仔细的计算和权衡我们发现一个字节给一个对应的地址是比较合适的。
 *
 * //如何编址?
 *  对于32位的机器，假设有32根地址线，那么假设每根地址线在寻址的时候产生高电平（高电压）和低电
 *  平（低电压）就是（1或者0）；
 *  那么32根地址线产生的地址就会是：
 * 00000000 00000000 00000000 00000000
 * 00000000 00000000 00000000 00000001
 * ...
 * 11111111 11111111 11111111 11111111
 * 这里就有2的32次方个地址。8bit==byte
 * //每个地址标识一个字节，那我们就可以给 （2^32Byte == 2 ^ 32 / 1024KB ==
 * //2 ^ 32 / 1024 / 1024MB == 2 ^ 32 / 1024 / 1024 / 1024GB == 4GB） 4G的空闲进行编址。
 * //同样的方法，那64位机器，如果给64根地址线，那能编址多大空间，自己计算


//那指针类型的意义是什么?
//指针的类型决定了指针向前或者向后走一步有多大（距离）(指针的步长)//指针+-整数
//指针类型决定了指针进行解引用操作时，能够访问空间的大小
////演示实例
//int main()
//{
//	int n = 0x11223344;
//	char *pc = &n;
//	int *pi = &n;
//
//  printf("%p\n",pc);==printf("%p\n",pi);

//&pi = 0 ;//00 00 00 00
//&pc = 0 ;//00 33 22 11

//	printf("%p\n",&n);     //00xx xxx1
//	printf("%p\n",pc);     //00xx xxx1
//	printf("%p\n",pc + 1); //00xx xxx2
//	printf("%p\n",pi);     //00xx xxx1
//	printf("%p\n", pi + 1);//00xx xxx5
//	return 0;

//}
 */

//野指针(危害，破坏)
//概念： 野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的）

//野指针成因
//1. 指针未初始化
//随机破坏
//
//2. 指针越界访问
//int main()
//{
//	int arr[10] = { 0 };
//	int *p = arr;
//	int i = 0;
//	for (i = 0; i <= 11; i++)
//	{
//		//当指针指向的范围超出数组arr的范围时，p就是野指针
//		*(p++) = i;
//	}
//	return 0;
//}
//
//3. 指针指向的空间(生命周期后)释放
//int* test()
//{
//	int a = 10;
//	return 0;
//}//结束后a释放了，a地址未知了
//int main()
//{
//	int *p = test();
//	*p = 20;//然后危险！！！
//	return 0;
//}


//如何规避野指针
//1. 指针初始化
//2. 小心指针越界
//3. 指针指向空间释放后 即（要）使指针置为NULL
//4. 避免返回局部变量的地址
//5. 指针使用之前检查有效性

//   *p++ 的理解
//   虽然++优先级高，但是后置++，则先算*p，再算++(实际上++已经进行，后置加加结果最后计算).

//不知道给指针初始化什么的时候，给赋值NULL
// int* p = NULL ;
// NULL 的定义 :(void*)0   ,把0强制转换成任意类型。
//此时不能访问空间不能赋值。直接运行会奔溃，调试则报错：0x00000000不能访问。


//2、指针减指针的绝对值（小减大得负数）：得到剩下的元素的个数。arr[9]-arr[0]=9//printf打印得9
//不能乱写，必须是同一个数组，不能是不同数组相减。会得到未知值，不知道是什么

//str只是编写程序的人员定义的一个变量, 常用来表示字符型变量或字符串, 取string的前三个字母

//应用：实现strlen函数
//int my_strlen(char* str)                //指针减指针法求strlen
//{
//	char* start = str;
//	char* end   = str;
//	while (end != '\0')
//	{
//		end++;
//	}
//	return end - start;
//}
//
//int main()
//{
//	char arr[] = "bit";
//	int len = my_strlen(arr);
//	printf("%d", len);//  3
//	return 0;
//}


//3、指针的关系运算：指针能比较大小，就是地址比较，大地址则大
//（指针+-整数）（指针+-指针）（指针比较大小）

//#define N_VALUES 5

//指针+-整数；指针的关系运算


//int main()
//{
//	float values[N_VALUES];
//	float *vp;
//	for (vp = &values[N_VALUES]; vp > &values[0];)//后到values[5]（数组最后为values[4]）
//	{
//		*--vp = 0;
//	}
	//代码简化, 这将代码修改如下：
	//for (vp = &values[N_VALUES - 1]; vp >= &values[0]; vp--) //前到-1
	//{
	//	*vp = 0;
	//}
	//实际在绝大部分的编译器上是可以顺利完成任务的，然而我们还是应该避免这样写，因为标准并不保证
	//它可行。
	//标准规定：
	//允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针比较，但是不允许与
	//指向第一个元素之前的那个内存位置的指针进行比较。
	//即可以arr[end]:(*vp=arr[end])+1,但不允许arr[0]:(*vp=arr[0])-1
//	return 0;
//}


//复习，数组首元素，有两个例外不是首地址，不表示整个首元素地址，而表示整个数组
//1、&arr - &数组名
//2、sizeof(arr) - sizeof(数组名)
//举例如下
//#include<stdio.h>
//int main()
//{
//	int arr[] = { 1, 2, 3, 4 };
//	printf("%p\n", arr);
//	printf("%p\n", arr + 1);//平移了一个元素的长度
//
//	printf("%p\n", &arr[0]);
//	printf("%p\n", &arr[0] + 1);//平移了一个元素的长度
//
//	printf("%p\n", &arr);
//	printf("%p\n", &arr + 1);//平移了整个数组的长度
//	return 0;
//}

//数组是数组，指针是指针，只是通过指针能访问数组

//_____________________________________________________________________________________
//   二级指针
//理解
//int mian()
//{
//	int a = 10;
//
//	int* pa = &a;         //*p是int类型，一层地址，一级指针，一个内容
//	int** ppa = &pa;      //*ppa是int*类型，二层地址，二级指针；**ppa是int类型，一层地址，一级指针，一个内容
//	int*** pppa = &ppa;   //*pppa是int**类型，三层地址，三级指针：类比下去
//  ...
  //a == *pa == **ppa = ***pppa;
  //pa == *ppa == **pppa;
  //ppa == *pppa
  //一个*为一把钥匙，一个p是一个门，
  //  a 门 门 门
  //     *  *  *
	
}

//_____________________________________________________________________________________
//好孩子 -- 孩子
//指针数组 -- 数组 - 存放指针的数组
//数组指针 -- 指针

//int main()  //指针数组举例
//{
//	int a = 10;
//	int b = 20;
//	int c = 30;
//	//int* pa = &a;
//	//int* pb = &b;
//	//int* pc = &c;
//	//整型数组 - 存放整型
//	//字符数组 - 存放字符
//	//指针数组 - 存放指针
//	int* arr[3] = { &a, &b, &c };//指针数组
//	for (int i = 0; i < 3; i++)
//	{
//		printf("%d ", *arr[i]);
//	}
//	return 0;
//}


//打印数的二进制各个奇数位和偶数位
//void Print(int num)
//{
//	printf("奇数位\n");
//	for (int i = 30; i >= 0; i -= 2)
//	{
//		printf("%d ", (num >> i) & 1);   //右移几位就干掉几位，剩n-i位
//	}
//	printf("\n");
//	printf("偶数位\n");
//	for (int i = 31; i >= 0; i -= 2)
//	{
//		printf("%d ", (num >> i) & 1);
//	}
//}
//
//int main()
//{
//	int num = 0;
//	scanf("%d", &num);
//	Print(num);
//	return 0;
//}

//计算power（次方）
//double Pow(int n, int k)
//{
//	//n^k=n*n^(k-1)
//	if (k > 0)
//		return n*Pow(n, k - 1);
//	else if (k == 0)
//		return 1;                    //结束当前函数，回到上个递归函数
//	else
//		return 1.0 / (Pow(n, -k));    //负数转换成正数，再进行计算分母
//}
//
//int main()
//{
//	int n = 0;
//	int k = 0;
//	scanf("%d%d", &n, &k);
//	double ret = Pow(n, k);
//	printf("%lf", ret);
//}


//逆序递归
//int my_strlen(char arr[])              //循环计数器法strlen
//{                                      //有三种my_strlen
//	int count=0;
//	
//	while (*arr != '\0') 
//	{
//		count++;
//		*arr++;
//	}
//	return count;
//}
//
//void reverse_string(char* str)  //逆序递归（拆盒子）
//{
//	//1、a和f交换
//	//2、进入剩下bcde逆序
//	//3、创造递归限制条件（积累），此处用\0，并以此引出my_strlen,实现找到尾字符
//	char tmp = str[0];
//	int len = my_strlen(str);
//	str[0] = str[len-1];
//	str[len - 1] = '\0';
//	if (my_strlen(str+1)>=2)       //逼近
//		reverse_string(str + 1);
//	str[len - 1] = tmp;
//}
//
//int main()
//{
//	char str[] = "abcdef";
//	reverse_string(str);             //reverse(逆转，颠倒，交换)，string(字符串)
//	printf("%s", str);          //字符串可以直接打印
//	return 0;
//}


//___________________________________________________________________________________
//结构体

struct tag//（tag标签）         //声明一个结构体类型
{
    //定义成员变量
	menber - listl;     //menber(成员)   list（列表; 名单; 清单; 目录）
}variable - list;      // 全局变量式类型声明（不推荐）
                       //variable（变量）

struct Stu     //描述一个学生的一些数据：年龄、名字、电话、性别
{
	//成员变量
	char name[20];
	short age;
	char tele[20];   //电话
	char sex[5];
}s1, s1, s3;       // 是三个 “ 全局 ” 的结构体变量（少用） 占用空间

struct Stu s4;     //也是全局变量。

//  struct - 结构体关键字    Stu - 结构体标签   struct Stu - 结构体类型！！！！！类型
//struct Stu
{
	//成员变量
	char name[20];
	short age;
	char tele[20];
	char sex[5];
};                      //先定义式类型声明（推荐）
//上不占
//类型不占空间，变量占用空间
//下占
int main()
{
	struct Stu s;  //                     结构体变量（推荐）  //占用空间（类型不占变量占）
}

//特殊结构体声明
//匿名结构体类型(不建议） //特点，只能定义一次变量。
struct//（不给结构体名字）
{
    int a;
    char b;
    float c;
}sa;//直接声明定义创建结构体变量（除此之外无法再声明变量）

//易出错的地方
struct
{
    int a;
    char b;
    float c;
}*psa;

psa = &sa;//会报错，编译器把*psa和sa当做两个不同的类型的变量（符合特点，只能定义一次变量）

//结构体的自引用（不能自己包含自己的类型，只能自己包含自己的类型的指针）
//错误的声明1
struct Node//(错误)链表的声明//（Node:节点）
{
    int data;
    struct Node n;//不是存放下一个节点，无限（死）递归，大小无限
};

//正确的声明1
struct Node//链表的声明
{
    int data;     //数据域（存放数据的地方）
    struct Node *next;//要存放下一个节点的地址。（指针域，存放指针的地方）
}

//typedef（用户类型定义）

typedef struct Stu
{
	char name[20];
	short age;
	char tele[20];
	char sex[5];
}Stu;//Stu不是变量，是类型         //将struct Stu 类型 重命名（定义）为 Stu 类型

//错误的声明2（先有鸡还是先有蛋）
typedef struct   //2.所以不要省略此处的命名，（少用匿名结构体）
{
    int data;
    Node* next;//1.还没重命名就声明->报错
}Node;

//正确的声明2
typedef struct Node
{
    int data;
    struct Node* next;
}Node;

int main()	     //下面声明的两种变量都能使用
{
	Stu s1;          //变量一
	struct Stu s2;   //变量二
}


//结构体成员：可以是标量，数组，指针，甚至是其他结构体
//标量类型就是标准变量类型，php自己造的概念，比如整型，浮点型，字符串型和布尔型(就是常说的变量)


//结构体初始化  --  简单情况

typedef struct Stu
{
	char name[20];
	short age;
	char tele[20];
	char sex[5];
}Stu;

int main()
{
	//数组初始化要用大括号{ }，结构体初始化一样使用大括号{ }。
	//内部按成员顺序一次赋值，并且相关符号按标量要求，如字符则用‘’，不同成员用逗号隔开
	Stu s1 = {"张三",20,"13500001111","男"};                 
	struct Stu s2 = { "李四", 19, "14700001111", "保密" };
    Stu s1 = { 0 };//这样可直接将所有成员都初始化成0；
	return 0;
}

//结构体大小计算公式sizeof(结构体变量名)

// 结构体初始化 ——  结构体内嵌结构体

struct S
{
	int a;
	char c;
	char arr[20];
	double d;
};

struct T
{
	char ch[10];
	struct S s;
	char *pc;
};

int main() //结构体变量的成员是通过点操作符（.）访问的，点操作符接收两个操作数
{
	char arr[] = "hello";
	//	T t1 = { " ", {}, NULL };                //
	struct T t2 = { "12345", { 1, '2', "123", 4.0 }, arr };
	printf("%s\n", t2.ch);
	printf("%d\n", t2.s.a);
	printf("%c\n", t2.s.c);
	printf("%s\n", t2.s.arr);
	printf("%1.1lf\n", t2.s.d); //控制左精度1位，右精度1位
	printf("%s\n", t2.pc);      //字符串能通过数组名%s直接打印
}

//结构体数组：变量名本身就是地址，不用再加&，加会警告
typedef struct BOOK
{
    int num;
    char name[20];
    int price;
}BOOK;
int main()
{
    BOOK book[3] = { 0, { 0 }, 0 };
    func(book);//直接传址
    return 0;
}

//注意： 结构体变量的赋值是不能采用大括号(列表初始化)的方式进行赋值的，例如下面的赋值是不允许的。
//A a;
//a = { 1, 2 }; // 错误赋值

//结构体赋值
下面列出常见结构体变量赋值的方法。
（1）使用 memset 对结构体变量进行置空操作：
// 按照编译器默认的方式进行初始化（如果 a 是全局静态存储区的变量，默认初始化为0，如果是栈上的局部变量，默认初始化为随机值）
A a;
memset(&a, 0, sizeof(a));
（2）依次给每一个结构体成员变量进行赋值：

A a;
a.b = 1;
a.c = 2;
（3）使用已有的结构体变量给另一个结构体变量赋值。也就是说结构体变量之间是可以相互赋值的。

A a = { 1, 2 };
struct A a1;
a1 = a;     // 将已有的结构体变量赋给a1


//结构体传参

// 任何一次函数调用，都会向内存申请空间
/* c语言中内存简单分为栈区、堆区、静态区。
* 栈区：局部变量开辟空间、函数形参开辟空间、函数调用开辟空间
* 堆区：动态内存分配：动态开辟的内存，如malloc/free、realloc、calloc
* 静态区：全局变量、static修饰的变量(静态变量)

c语言中内存简单分为栈区、堆区、静态区。如

 ------------------------
| ---------------------- |
||  局部变量开辟空间    ||
||                      ||
||  函数形参开辟空间    ||          栈区
||                      ||
||  函数调用开辟空间    ||
||----------------------||
||  动态内存分配        ||
||  malloc/free         ||
||  realloc             ||          堆区（专门用来动态内存分配）
||  calloc              ||
||                      ||
||----------------------||
||  全局变量            ||
||  static修饰的变量    ||           静态区
||  (静态变量)          ||
| ---------------------- |
 ------------------------ 

 */

//结构体调用的说明

//   结构体传参时，哪种方式好？：传址调用最好
typedef struct Stu
{
	char name[20];
	short age;
	char tele[20];
	char sex[5];
}Stu;

//传值调用时，参数是需要压栈的。如果传递一个结构体对象时结构体过大，参数压栈的系统开销比较大，
//会导致性能下降
void Print1(Stu s)        //传值调用，形参是实参的一份拷贝，意味着要开辟空间，当结构体较大时，
{                    //性能就会受影响，拷贝要时间，空间也浪费，
	printf("%s\n", s.name);
	printf("%d\n", s.age);
	printf("%s\n", s.tele);
	printf("%s\n", s.sex);
}

void Print2(Stu* s)              //过渡，不使用，*必须有括号，一般用Print3，
{
	printf("%s\n", (*s).name);
	printf("%d\n", (*s).age);
	printf("%s\n", (*s).tele);
	printf("%s\n", (*s).sex);
}

void Print3(Stu* s)
{
	printf("%s\n", s->name);
	printf("%d\n", s->age);
	printf("%s\n", s->tele);
	printf("%s\n", s->sex);
}

int main()   //报错原因：成员类型与转换规范（打印格式）不一致，导致无法写入
{
	Stu s = { "1", 2, "3", "4" };
	Print1(s);
	Print2(&s);
	Print3(&s);
	return 0;
}

//压栈
//栈区原理，以Add函数为例：
int Add(int x, int y)
{
	int z = 0;
	z = x + y;
	return z;
}

int main()
{
	int a = 10;
	int b = 20;
	int ret = Add(a, b);
	return 0;
}

          /*	栈区如图								  /\
           ------------------------						 /||\
          | ---------------------- |					  ||
          ||                      ||					  ||
          ||                      ||					  ||
          ||                      || 					  ||
          ||                      ||					  ||
          ||                      ||					  ||
          ||                      ||					  ||
          ||----------------------||					  ||
          ||                      ||					  ||   压
          ||        （Add）       ||					  ||
          ||                      ||					  ||   栈
          ||  [       z       ]   ||<----			6	  ||
          ||----------------------||     |				  ||
          ||----------------------||     |				  ||
          ||                      ||     |				  ||
          ||                      ||     |				  ||
      --->||  [    x(参数a)   ]   ||-----|			5	  ||
  ---|--->||  [    y(参数b)   ]   ||-----			4	  ||
 |   |    ||----------------------||					  ||
 |   |    ||----------------------||_______				  ||
 |   |    ||                      ||       |			  ||
 |   |    ||                      ||       |			  ||
 |   |    ||                      ||       |-main		  ||
 |   |    ||  [       ret     ]   ||       |		3	  ||
  ---|----||  [       b       ]   ||       |		2	  ||
      ----||  [       a       ]   ||_______|		1     ||  
          | ---------------------- |
           ------------------------
           */


//数据结构
/*-----------*  线
 * 顺序表	 *  性  （连续空间）
 * 链表	     *  数  （不连续空间，通过指针链接）
 * 栈		 *  据  （装箱子，必须一个一个放，一个一个取、出，上进上出,放叫压栈，出叫出栈。先进后出，后进先出)
 * 队列	     *  结
 *-----------*  构
 */

//树形数据结构（二叉树、图）


//函数栈帧的创建和销毁（栈帧：空间管理的动作，创建、释放等）




//_____________________________________________________________________________________
//Debug和Release

//Debug 通常称为调试版本，他包含调试信息，并且不作任何优化，便于程序员调试程序
//Release称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用

//Debug 包含调试信息，占空间大，可以调试
//Release 占空间小，不可以调试

//Debug和Release功能和优化上有所不同

//release 版本虽然由优化，但是不明优化规则，可能也会导致bug

#include <stdio.h>
int main()
{
	int i = 0;
	int arr[10] = { 0 };
	//VC++6.0环境下 <=10  死循环
	//gcc编译器    <=11  死循环
	//VS2013      <=12  死循环
	for (i = 0; i <= 12; i++)
	{
		arr[i] = 0;
		printf("hehe\n");
	}
	return 0;
}
//函数有两个概念（压栈顺序和计算顺序）
//压栈顺序知识点
//1.栈是先进后出的结构
//2.ebp：基地址寄存器 （栈底）
//esp：栈指针 （栈顶）
//3.栈底到栈顶的内存地址是由高到低。就是10->1。
//创建一个函数，函数压栈的顺序是从右往左，先压b，然后再a。
//原因是两个
//1.出栈的时候就可以按顺序获取a、b。
//2.针对可变参数函数（这个需要好好研究，目前不确定，等搞汇编后再看看）

/*
------------------------    高地址(EBP栈底)
|    0    (i)   arr[12] |                      1、局部变量放栈区
|    0          arr[11] |    （为什么i刚好多2，而不是其他：由编译器决定，本身便如此）
|    0          arr[10] |					   2、栈区的默认使用:先使用高地址处的空间
|    0          arr[ 9] |					   再使用低地址处的空间
|    0          arr[ 8] |
|    0          arr[ 7] |					   3、数组随着下标的增长地址是由低到高变化
|    0          arr[ 6] |
|    0          arr[ 5] |
|    0          arr[ 4] |
|    0          arr[ 3] |
|    0          arr[ 2] |
|    0          arr[ 1] |
|    0          arr[ 0] |
|                       |
|                       |
|                       |	低地址（ESP栈顶） //后进后出
| ----------------------|
*/


//_____________________________________________________________________________________
//代码优化
/* 1、分析参数的设计（命名、类型），返回值类型的设计
 * 2、涉及到指针要防止出现野指针，必须在指针解引用前，保证指针的有效性
 * 3、使用assert，提示错误问题
 * 4、参数部分能否使用const修饰指针
 * 5、注释添加
 * 6、相同合并（先举出所有可能，逐步检查，找出有共通的合并，排斥的分开）
 */

//函数处理：返回类型，参数限定，表达式代码优化，有错误检查。四点

/*
 *
 *
 *
 *
 */


//destination(终点;目的地)   source(源头)
//void my_strcpy(char* dest, char* src)//版本一
//{
//	while (*src != '\0')
//	{
//		*dest = *src;
//		src++;
//		dest++;
//	}
//	*dest = *src;
//}

//void my_strcpy(char* dest, char* src)//法二
// 满足递进关系与后置++，简化代码
//（缺点，指针解引用前无保护）
//{
//	while (*dest++ = *src++)  //运用 '\0' 为假（ascii为0），控制循环
//	{1
//		;
//	}
//}

//void my_strcpy(char* dest, char* src)//优化三:在解引用指针前，判断指针的有效性（必须）
//   //（虽防止出现野指针，但没提示出哪里出错）
//{
//	if (src != NULL&&dest != NULL)
//	{
//		while (*dest++ = *src++)
//		{
//			;
//		}
//
//	}
//}

//#include<assert.h>
//void my_strcpy(char* dest, char* src)//法四：断言法(在保护的基础上，告诉错误在哪)
////编写代码时，我们总是会做出一些假设，断言就是用于在代码中捕捉这些假设，可以将断言看作是异常处理的一种高级形式。
//{
//	assert(dest != NULL);           //fail(失败，不成功)
//	assert(src != NULL);
//	if (src != NULL)
//	{
//		while (*dest++ = *src++)
//		{
//			;
//		}
//
//	}
//}

//#include<assert.h>
//char* my_strcpy(char* dest, const char* src)//优化五：常变量修饰参数与返回值类型
////1、为防止下面表达式写错，用const限制*src不能被修改（防止*dest赋给*src）
////2、确保结果与目标相同，将返回目的地（结果）的地址，便于后续操作验证与使用
//{
//	char* ret = dest;   //在开始前就保存好目的地地址，便于后续修改后可以找到起点
//	assert(dest != NULL);           //fail(失败，不成功)
//	assert(src);//(NULL==0)      //assert(src != NULL);
//	if (src != NULL)
//	{
//		while (*dest++ = *src++)
//		{
//			;
//		}
//
//	}
//	return ret;
//}
//

//const指针使用
//const 放在指针变量的*左边时，修饰的是*p，也就是说p可以改，但*p不行，即不能通过p来改变*p的值
//const 放在指针变量的*右边时，修饰的是指针变量p本身，p不能改了，但*p（p指向的对象）可以修改
//const 也可以两边都放，即两个都修饰
//如const int num = 10,const int n = 100;

//0、num=100;  //报错，num已经不能直接修改
   //但是可以通过指针修改，即不能从变量名上去修改，但可以从地址去修改

//1、const int* p = &num
//*p = n  //报错
//p = &n  //num = 100
//
//2、int* const p = &num;
//*p = n   // num = 100
//p = &n   //报错

//int	main()
//{
//	char arr1[] = "##############";
//	char arr2[] = "hello";
//	my_strcpy(arr1, NULL);            //此处错误还没改
//	printf("%s\n", arr1);
//	printf("%s\n", my_strcpy(arr1, NULL)); //最终版本 //函数的返回值作为另一个函数的参数（链式访问）
//	return 0;
//}

//比较完美的my_strlen
//#include<assert.h>
//#include <stdio.h>
//int my_strlen(const char *str) {
//	int count = 0;
//	assert(str != NULL);
//	while (*str++ != '\0')//判断字符串是否结束
//	{
//		count++;
//		//str++;
//	}
//	return count;
//}
//int main()
//{
//	const char* p = "hello";
//	//测试
//	int len = my_strlen(p);
//	printf("len = %d\n", len);
//	return 0;
//}

//_____________________________________________________________________________________
//编程常见的错误
//7.1 编译型错误
//直接看错误提示信息（双击），解决问题。或者凭借经验就可以搞定。相对来说简单。
//7.2 链接型错误
//看错误提示信息，主要在代码中找到错误信息中的标识符，然后定位问题所在。一般是标识符名不
//存在或者拼写错误。
//7.3 运行时错误
//借助调试，逐步定位问题。最难搞。




//_____________________________________________________________________________________
//数据类型

//不同类型元素的地址都是首地址，由类型确定后续空间

//类型的意义：
//1. 使用这个类型开辟内存空间的大小（大小决定了使用范围）。
//2. 如何看待内存空间的视角。
//栈的内存开辟是从高地址往低地址段开辟, 但是读取内存都是从低地址往高地址读取的


//1.1 类型的基本归类：
//整形					         构造类型：				            浮点型:
//char				           > 数组类型:int[10],int[5]	        float
//unsigned char		           > 结构体类型 struct		            double
//signed char			       > 枚举类型 enum
//short				           > 联合类型 union
//unsigned short[int]
//signed short[int]
//int						   指针类型：	        空类型：
//unsigned int				   int *pi;			    void 表示空类型（无类型）
//signed int				   char *pc;		    通常应用于函数的返回类型、函数的参数、指针类型。
//long						   float* pf;           void*（通用类型）不能解引用，不能加减操作 
//unsigned long[int]		   void* pv;
//signed long[int]             (指针类型大小是统一的）

//short和long都可以省略int
//

//（整数）数据的二进制表示方法：只有有符号的负数区分原、反、补。其他（有符号正数和无符号数）原、反、补相同
//浮点数完全不一样，未学

//在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统
//一处理；
//同时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程
//是相同的，不需要额外的硬件电路。

//地址与数位
//数位从右往左读增大，地址由右往左增大
// 【高           （数字）        低】     // 【低           （地址）        高】
//             下面的二进制都是数据在内存中的位置
//       00 00 00 01(数据)         |             01  00  00  00(小端放法)
//       00 00 00 01(数据)         |             00  00  00  01(大端放法)
//                                  指针读取 ->  |    |       |
//										       char  short   int

//如 地址0x 40 b0 00 00在小端内存中放法为00 00 b0 40

//2.2 大小端介绍
//什么大端小端：
//大端（存储）模式，是指数据的低位保存在内存的高地址中，
//而数据的高位，保存在内存的低地址中；（大端字节序）
//小端（存储）模式，是指数据的低位保存在内存的低地址中，
//而数据的高位 ，保存在内存的高地址中。（小端字节序）
//为什么有大端和小端：
//为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元
//都对应着一个字节，一个字节为8


//都对应着一个字节，一个字节为8
//bit。但是在C语言中除了8 bit的char之外，还有16 bit的short型，32 bit的long型（要看具体的编
//译器），另外，对于位数大于8位
//的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如
//何将多个字节安排的问题。因此就
//导致了大端存储模式和小端存储模式。
//例如：一个 16bit 的 short 型 x ，在内存中的地址为 0x0010 ， x 的值为 0x1122 ，那么 0x11 为
//高字节， 0x22 为低字节。对于大端
//模式，就将 0x11 放在低地址中，即 0x0010 中， 0x22 放在高地址中，即 0x0011 中。小端模式，
//刚好相反。我们常用的 X86 结构是
//小端模式，而 KEIL C51 则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以
//由硬件来选择是大端模式还是小端
//模式

//内存是小端存储模式（其他设备不一样，具体自己看内存）

//类型读取操作从左到右。

//int check_sys()
//{
//	int a = 1;     //a的值为0x00 00  00 01  或0x 01 00 00 00
//	char* p =(char*)&a;  //*p的值为0x00 或0x01
//	if (*p == 1)//*p==1或*p==0,由此可优化得
//		return 1;
//	else
//		return 0;
//}

//int check_sys()//优化一
//{
//	int a = 1;     //a的值为0x00 00  00 01  或0x 01 00 00 00
//	char* p = (char*)&a;  //*p的值为0x00 或0x01
////*p==1或*p==0,由此可优化得
//		return *p;//返回1小端，返回0大端
//}

//int check_sys()//优化二
//{
//	int a = 1;     //a的值为0x00 00  00 01  或0x 01 00 00 00
//	return *(char*)&a;//返回1小端，返回0大端
//}
//
//int main()   //判断是大端还是小端
//{
//	int ret = check_sys();
//	if (ret == 1)
//		printf("小端\n");
//	if (ret == 0)
//		printf("大端\n");
//	return 0;
//}



/*
char 有符号数  补码 存放                             无符号数
一共有256=2^8			                             无符号char的 范围是0-255
内存											      内存
--------------								         --------------
|  0000 0000  |    0							    |  0000 0000  |    0
|  0000 0001  |    1							    |  0000 0001  |    1
|  0000 0010  |    2							    |  0000 0010  |    2
|  0000 0011  |    3							    |  0000 0011  |    3
|  0000 0100  |    4							    |  0000 0100  |    4
|  ...        |            					        |  ...        |
|  0111 1111  |   127							    |  0111 1111  |   127
|  1000 0000  |  -128							    |  1000 0000  |   128
|  1000 0001  |  -127       					    |  1000 0001  |   129
|  ...        |            					        |  ...        |
|  ...        |            					        |  ...        |
|             |         						    |             |
|  1111 1101  |    -3							    |  1111 1101  |   253
|  1111 1110  |    -2							    |  1111 1110  |   254
|  1111 1111  |    -1							    |  1111 1111  |   255
|             |         						    |             |
| ------------|								        | ------------|
 


-128为规定，据说因1 1000 0000 的原码和补码一致而定
由负数部分可以发现，负数补码+正数=0000000


                             >
         1111 1111(-1)                    0000 0000(0)
      0000 0001(1)
   0000 0010(2)
 ...				        	          	           ...
...				        	 圆        		              ...
 ...		        	          		               ...

     1000 0001(-127)                        01111 1110(126)
         1000 0000(-128)                 0111 1111(127)

                              <


//_____________________________________________________________________________________
//      浮点
*/

//1E10==1.0*10^10

//浮点型，float·double·long double 类型。浮点数表示
//整型的范围在文件limits.h ;  浮点型的头文件在float.h;
//C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\include

//int main()
//{
//	int n = 9;
//	float *pFloat = (float *)&n;
//	printf("n的值为:%d\n", n);				//  n的值为:9
//	printf("*pFloat的值为:%f\n", *pFloat);	//  *pFloat的值为:0.000000
//	//可以发现，整型和浮点型存放并不相同
//	*pFloat = 9.0;
//	printf("n的值为:%d\n", n);				//	n的值为:1091567616
//	printf("*pFloat的值为:%f\n", *pFloat);	//	*pFloat的值为:9.000000
//}
//9.0
//1001.0
//(-1) ^ 0 * 1.001 * 2 ^ 3;
//(-1) ^ S *     M * 2 ^ E;



//根据国际标准IEE（电气与电子工程协会)754,任意一个二进制浮点数V可以表示成下面的形式：
//(-1) ^ S * M * 2 ^ E （结果为十进制）
//(-1) ^ S 表示符号位，当s = 0，V为正数；当s = 1, V为负数
//M 表示有效数字，大于等于1，小于等于2.（因为是二进制）
//2 ^ E 表示指数位
//
//举例：
//十进制的5.0，写成二进制是101.0，相当于1.01 * 2 ^ 2。由规定得
//S = 0，M = 1.01，E = 2;
//十进制得 - 5.0，写成二进制是 - 101.0, 相当于 - 1.01 * 2 ^ 2，由此
//S = 1，M = 1.01, E = 2;
//
//IEEE 754规定：对于32位的浮点数，最高的一位是符号位，接着的8位是指数位E，剩下的23位为有效数字M
//0          0000-0000             0000-0000-0000-0000-0000-000
//S(1bit)     E(8bit)                   M(23bit)
//
//对于64位的浮点数，最高的一位是符号位S，接着的11位是指数E，剩下的52位有效数字M
//0          0000 - 0000 - 000     00000000000000000000000000000000000000000000000000 - 00
//S(1bit)     E(11bit)                  M(52bit)


//IEEE 754对有效数字M和指数E，还有一些特别规定。
//前面说过， 1≤M<2 ，也就是说，M可以写成 1.xxxxxx 的形式，其中xxxxxx表示小数部分。
//IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的
//xxxxxx部分。比如保存1.01的时
//候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位
//浮点数为例，留给M只有23位，
//将第一位的1舍去以后，等于可以保存24位有效数字。

//至于指数E，情况就比较复杂。
//首先，E为一个无符号整数（unsigned int）
//这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们
//知道，科学计数法中的E是可以出现负数的，
//所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，
//对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。
//比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10 + 127 = 137，即10001001。

//int main()//放入浮点型的过程
//{
//	float f = 5.5; (0.5便于写成二进制，其他的无限)
//101.1 = 101.2^-1   //位权累加比较法：如0.14,2^-1=0.5太大，2^-2=0.25>0.14,2^3=0.125,所以0.001......
//(-1) ^ 0 * 1.011 * 2 ^ 2
//S = 0, M = 1.011, E = 2
//0    2+127    .011
//0 1000-0001  0110-0000-0000-0000-0000-000//(小数是反过来放的，即从头开始)
//0100 0000 1011 0000 0000 0000 0000 0000  //十六进制过程
//0x40 b0 00 00---------------------存储显示00 00 b0 40
//	return 0;
//}

//然后，指数E从内存中取出还可以再分成三种情况：
//E不全为0或不全为1（正常情况）
//这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将
//有效数字M前加上第一位的1。
//
//E全为0（很小的数）
//这时，浮点数的指数E等于1 - 127（-126）或者1 - 1023（-1022）即为真实值，
//有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于
//0的很小的数字。
//0 0000-0000 0110-0000-0000-0000-0000-000
//+/- 0.011 * 2 ^ -127（-127+127）//原本
//+/- 0.011 * 2 ^ -126（-127+127）//定义
//
//E全为1（很大的数）
//这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；
//0 1111-1111 0110-0000-0000-0000-0000-000
//E+127 = 255//+127保证无符号的中间值
//E=255-127=128
//+/- 1.011 * 2^128//了解，差不多


//int main()回头复习
//{
//	int n = 9;
//	float *pFloat = (float *)&n;
//直接将n的二进制补码放进去00000000 00000000 00000000 00001001
//浮点0 00000000 00000000000000000001001    (指数全零)
//(-1) ^ 0 * 0.00000000000000000001001 * 2 ^ -126   //不是十进制，但由于无限小，故%f为0.000000
//	printf("n的值为:%d\n", n);				//  n的值为:9
//	printf("*pFloat的值为:%f\n", *pFloat);	//  *pFloat的值为:0.000000

//	*pFloat = 9.0;//1001.0==1.001*2^3
//0 10000010 001-0000-0000-0000-0000-0000
//%d打印会非常大01000001000100000000000000000000=1091567616
//	printf("n的值为:%d\n", n);				//	n的值为:1091567616
//	printf("*pFloat的值为:%f\n", *pFloat);	//	*pFloat的值为:9.000000
//}

//_____________________________________________________________________________________
//字符串常量(本身就是地址，不用&,输出就是数值，无需解引用)

//定义：用双引号“”括起来的0个或者多个字符组成的序列
//存储：字符串中的字符依次存储在内存中一块连续的区域内，并且把空字符‘ \0’自动附加到
//字符串的尾部作为字符串的结束标志。故字符个数为n的字符串在内存中应占（n + 1）个字节。
//
//
//在程序中，字符串常量会生成一个“指向字符的常量指针”。当一个字符串常量出现于一个表达式中时，
//表达式所使用的值就是这些字符所存储的地址，而不是这些字符本身。
//因此，你可以把字符串常量赋值给一个“指向字符 的指针”，
//字符串常量可以赋值给字符数组：char a[10] = "love";
//可以赋值给指针：char *a = "123"; a = "abc";//赋的是首地址

//int main()
//{
//字符常量可以赋值给字符变量，如char b='a'; 但不能把一个字符串常量赋给一个字符变量
//char a = "abcdef";//错误
//char* pc = a;     //错误
//	char* p = "abcdef";
//字符串常量放进是地址，输出是数值，无需取地址，所以指针可直接接收，printf能直接打印
//	printf("%c\n", *p);//a//赋的是首地址
//	printf("%s\n",  p);//abcdef
//	return 0;
//}

//segmentation fault 段错误，数组越界访问，非法访问
//www.segmentfalult.com思否

//int main()  //不安全
//{
//	char* p = "abcdef";
//	*p = 'W';//错误代码，segmentation fault 段错误，数组越界访问，非法访问
//	printf("%s", p);
//	return 0;
//}

//int main() //优化
//{
//	const char* p = "abcdef";   //正确使用，保护手段，每次用字符串常量都加上
//	*p = 'W';
//	printf("%s", p);
//	return 0;
//}


//int main()
//{
//	char arr1[] = "abcdef";
//	char arr2[] = "abcdef";
//	const char* p1 = "abcdef";
//	const char *p2 = "abcdef";
//		if (arr1 == arr2)
//			printf("are same\n");
//		else
//			printf("are not same\n");
//p1和p2指向的是一个同一个常量字符串。有些编译器C / C++会把常量字符串存储到单独的一个内存区域
//		if (p1 == p2)
//			printf("are same\n");
//		else
//			printf("are not same\n");
//		return 0;
//结果vc++6.0为not，smae
//vs2013为not，not（老师的为not，same）
//只能说不同编译器优化不同吧。。。
//}
//这里p1和p2指向的是一个同一个常量字符串。C / C++会把常量字符串存储到单独的一个内存区域，当
//几个指针。指向同一个字符串的时候，他们实际会指向同一块内存。但是用相同的常量字符串去初始化
//不同的数组的时候就会开辟出不同的内存块。所以arr1和arr2不同，p1和p2相同（可能不同）

//_____________________________________________________________________________________
//数组
//数组名和指针有区别，数组名地址不会改变，而指针会变，example： arr+1，p+1

//_____________________________________________________________________________________
//指针数组
//int main()
//{
//    int arr1[] = { 1, 2, 3, 4, 5 };
//    int arr2[] = { 2, 3, 4, 5, 6 };
//    int arr3[] = { 3, 4, 5, 6, 7 };
//    int* parr[] = { arr1, arr2, arr3 };
//    int i = 0;
//    for ( i = 0; i < 3; i++)
//    {
//        int j = 0;
//        for ( j = 0; j < 5; j++)
//        {
//            printf("%d ", *(parr[i] + j));
//        }
//        printf("\n");
//    }
//    return 0;
//}

//_____________________________________________________________________________________
//指针数组
//int * p; 指向整形数据的指针可以指向整型变量
//int* p = arr//可以指向整型数组元素,
//int* p1[10]; //p[10]先结合成为数组，剩下int*即为类型，即指向int*的数组:类型为int*[10]的数组
//int (*p2)[10];//（*p2)先结合成指针，剩下int[10]为类型，即指向数组[10]的指针：指向int[10]的指针
//int(*p[10])[5];//p[10]为数组，*p[10]为指针数组，p[10]是指向类型为int[5]的指针：二维数组
//该数组有10个元素，每个元素是一个数组指针，该数组指针指向的数组有5个元素，每个元素是int

//int(*p)[10];
//解释：p先和*结合，说明p是一个指针变量，然后指着指向的是一个大小为10个整型的数组。所以p是一个
//指针，指向一个数组，叫数组指针。
//这里要注意：[]的优先级要高于*号的，所以必须加上（）来保证p先和*结合。
//类型：int(*)[10]

//所以
//可以取出一整个数组的地址给数组指针
//int(*p)[5] = &arr;

//int main()
//{
//    int arr[5] = { 1, 2, 3, 4, 5 };
//    int(*p)[5] = &arr;
////  printf("%d", arr);//因为错误
////  printf("%d", *p);//所以错误
//    printf("%d", *p[0]);
//    printf("%d", (*p)[0]);
//
//    return 0;
//}
//void print1(int arr[3][5], int x, int y)
//{
//    int i = 0, j = 0;
//    for ( i = 0; i < 3; i++)
//    {
//        for ( j = 0; j < 5; j++)
//        {
//            printf("%d ", arr[i][j]);
//            printf("%d ", *(*(arr+i)+j));
//            printf("%d ", (*(arr+i))[j]);
//            printf("%d ", *(arr[i]+j));
//        }
//        printf("\n");
//    }
//}
//
//void print2(int(*p)[5], int x, int y)
//{
//    int i = 0, j = 0;
//    for ( i = 0; i < 3; i++)
//    {
//        for ( j= 0; j < 5; j++)
//        {
//            //arr[row][col]：行地址，列地址，元素=====>
//            printf("%d ", *(*(p + i) + j));//*(p+i)指向列（第二层）的首地址，所以能接+j
//            printf("%d ", *(p[i] + j)); //p[i]指向第二层首地址
//            printf("%d ", (*(p + i))[j]);//*(p+i)指向列（第二层）的首地址，所以能接[j].
//            printf("%d ", p[i][j]);    //简化
//        }
//        printf("\n");
//    }
//}
//
//
//
//int main()
//{
//    int arr[3][5] = { { 1, 2, 3, 4, 5 }, { 2, 3, 4, 5, 6 }, { 3, 4, 5, 6, 7 } };
////  二维数组之首地址其实是第一行，把二维数组看成一维数组，
////  int arr[3][5]实际为一维有三个元素，其元素类型为int[5]。由此，引入数组指针
//    print1(arr, 3, 5);
//    print2(arr, 3, 5);
//}


//_____________________________________________________________________________________
//一维数组传参接收命名
//void test(int arr[])
//{}
//
//void test(int arr[10])
//{}
//
//void test(int* arr)
//{}
//
//void test2(int* arr[])
//{}
//
//void test2(int* arr[20])
//{}
//
//void test2(int** arr) //二级指针，两层地址：数组名->数组元素（地址）->元素指向
//{}
//
//
//int main()
//{
//    int arr[10] = { 0 };
//    int* arr2[20] = { 0 };
//    test(arr);
//    test2(arr2);
//    return 0;
//}

//void test(int arr[3][5])
//{}
//
//void test(int arr[][5])//最多省略行，不能省略列
//{}
//
//void test(int(*arr)[])
//{}
//
//void test(int* arr) //error      int不匹配
//{}
//
//void test(int** arr)  //error    int* 不匹配
//{}
//
//void test(int* arr[5])//error    int*（二级指针）不匹配
//{}
//
//int main()
//{
//    int arr[3][5] = { 0 };
//    test(arr);     //arr为int[5]类型（一级指针数组）
//
//}

//指针传参一定要匹配相对应的层次，


//_____________________________________________________________________________________
//函数指针
//void (*p)(int,int);  //语法::> 返回值 (*函数指针名)(类型...) 
//---------------------------------------------------------------void* p(int,int);   //error:p先和函数（）结合成函数名，返回值为void*
//该函数指针的类型是 void (*)(int,int)
//指针变量是p ,类型是 void(*)(int,int)

//函数指针类型重命名:
//typedef void(*p)(int,int) //把void(*)(int,int)类型重命名成p //方便使用函数类型,不用再写一大串函数类型如void(*)(int,int)   fun(){};

//函数地址
//&函数名和函数名都是函数的地址。

//void Print(char*str)
//{
//    printf("%s\n", str);
//}
//
//int main()
//{
//    void(*p)(char*) = Print;//函数指针的参数无需命名（可以命名），因为用不到，中转后传给函数
//    (*p)("hello");
//    return 0;
//}

//函数指针重命名
//typedef unsigned int uint;              //true
//typedef void(*)(int) pfun_t;            //error（错误）  fales（非法，假） fault(故障)
//typedef void(*pfun_t)(int);             //true（真） 
   //语法: typedef 返回值类型(*函数指针重命名)(参数); //--基本上和函数指针一样

//void(*signal(int, void(*)(int)))(int);
//pfun_t signal(int, pfun_t);

//int Add(int x, int y)
//{
//    return x + y;
//}
//
//int main()        //
//{
//    int(*p)(int, int) = Add;
//    printf("%d\n", p(2, 3));
//    printf("%d\n", (*p)(2, 3));
//    printf("%d\n", (**p)(2, 3));
//    printf("%d\n", (****************p)(2, 3));//解引用对函数指针无影响，直接用就行
//    return  0;
//}

//
//函数指针数组
//定义 int (*p[10])(int,int)
//调用
//int main()
//{
//    int(*p[4])(int, int) = { Add, Sub, Mul, Div };
//    printf("%d\n", p[0](2, 3));
//    return 0;
//}

//简易计算器1.0
//#include<stdio.h>
//#include<stdlib.h>
//double Add(double x,double y)    //add
//{
//    return x + y;
//}
//
//double Sub(double x, double y)  //subtract
//{
//    return x - y;
//}
//
//double Mul(double x, double y)  //multiply 
//{
//    return x * y;
//}
//
//double Div(double x, double y)  //divide
//{
//    return (double)(x / y);
//}
//
//menu()
//{
//    printf("********************************\n");
//    printf("***     1.求和         2.求差***\n");
//    printf("***     3.求积         4.求商***\n");
//    printf("***     0.exit               ***\n");
//    printf("********************************\n");
//    printf("输入对应指令，按回车键结束      \n");
//
//}
//
//void Print(double ret)//特定函数名用大写的目的是防止与库函数相同
//{
//    printf("%lf\n", ret);
//}
//
//int main()  //简易计算器1.0
//{
//    int input = 1;
//    double ret = 0;
//    double x = 0 , y = 0;
//    while (input)
//    {
//        menu();
//        scanf("%d", &input);
//        if (input == 0)
//            exit(1);
//        printf("请输入两个操作数\n");
//        scanf("%lf%lf", &x, &y);
//        switch (input)
//        {
//
//        case 1:ret = Add(x, y); break;
//        case 2:ret = Sub(x, y); break;
//        case 3:ret = Mul(x, y); break;
//        case 4:ret = Div(x, y); break;
//        default:
//            printf("输入有误，请重新输入");
//            break;
//        }
//        Print(ret);
//        system("pause");
//        system("cls");
//    }
//    return 0;
//}
///////////////////////////////////////////////////////////

//#include<stdio.h>
//#include<stdlib.h>
//double Add(double x, double y)    //add
//{
//    return x + y;
//}
//
//double Sub(double x, double y)  //subtract
//{
//    return x - y;
//}
//
//double Mul(double x, double y)  //multiply 
//{
//    return x * y;
//}
//
//double Div(double x, double y)  //divide
//{
//    return (double)(x / y);
//}
//
//menu()
//{
//    printf("********************************\n");
//    printf("***     1.求和         2.求差***\n");
//    printf("***     3.求积         4.求商***\n");
//    printf("***     0.exit               ***\n");
//    printf("********************************\n");
//    printf("输入对应指令，按回车键结束      \n");
//
//}
//
//void Print(double ret)//特定函数名用大写的目的是防止与库函数相同
//{
//    printf("%lf\n", ret);
//}
//
//int main()  //简易计算器2.0(函数指针数组----转移表)//数量大时可以简化switch
//{
//    int input = 1;
//    double ret = 0;
//    double x = 0, y = 0;
//    while (input)
//    {
//        menu();
//        scanf("%d", &input);
//        if (input == 0)
//            exit(1);
//        else if (input >= 1 && input <= 4)
//        {
//            printf("请输入两个操作数\n");
//            scanf("%lf%lf", &x, &y);
//            double(*pFun[5])(double, double) = { 0, Add, Sub, Mul, Div };
//            ret = pFun[input](x, y);
//            Print(ret);
//        }
//        else
//        {
//            printf("输入有误，请重新输入\n");
//        }
//        system("pause");
//        system("cls");
//    }
//    return 0;
//}

/////////////////////////////////////////////////////////////////////////
//回调函数（解决代码重复冗ron余）

//#include<stdio.h>
//#include<stdlib.h>
//double Add(double x, double y)    //add
//{
//    return x + y;
//}
//
//double Sub(double x, double y)  //subtract
//{
//    return x - y;
//}
//
//double Mul(double x, double y)  //multiply 
//{
//    return x * y;
//}
//
//double Div(double x, double y)  //divide
//{
//    return (double)(x / y);
//}
//
//menu()
//{
//    printf("********************************\n");
//    printf("***     1.求和         2.求差***\n");
//    printf("***     3.求积         4.求商***\n");
//    printf("***     0.exit               ***\n");
//    printf("********************************\n");
//    printf("输入对应指令，按回车键结束      \n");
//
//}

//void calc(double (*pf)(double, double))
//{
//    double x, y = 0;
//    printf("请输入两个操作数\n");
//    scanf("%lf%lf", &x, &y);
//    printf("%lf", pf(x,y));
//}
//
//int main()  //简易计算器3.0//回调函数(通过另一个函数调用想要的函数)解决代码重复冗ron余
//{
//    int input = 1;
//    while (input)
//    {
//        menu();
//        scanf("%d", &input);
//        if (input == 0)
//            exit(1);
//        switch (input)
//        {
//
//        case 1:calc(Add); break;
//        case 2:calc(Sub); break;
//        case 3:calc(Mul); break;
//        case 4:calc(Div); break;
//        default:
//            printf("输入有误，请重新输入");
//            break;
//        }
//        system("pause");
//        system("cls");
//    }
//    return 0;
//}


//指向函数指针数组的指针
//int(*pf)(int, int);//函数指针
//类型int
//int(*pfArr[4])(int, int);//函数指针数组
//类型int*(int,int)
//int(*(*pfArr[4]))(int, int) = &pfArr;//指向函数指针数组的指针
//类型int(*)(int,int)

//_____________________________________________________________________________________
//指针待续











//_____________________________________________________________________________________
//字符串函数(基本都与\0有关)
//操作对象是字符串（每次操作一个字节，所以其他类型不兼容（可以操作，但字节不符合，不能实现））
//求字符串长度strlen
//目前有种方法模拟1、计数器  2、递归  3、指针-指针

//长度不受限制的字符串函数:只受\0控制，非法也执行，不能控制，不够安全
//strcpy strcat(strcpy改进版) strcmp  

//长度受限制的字符串函数
//strncpy strncat  strncmp

//对于strcat（追加）不能自己追自己，因为写入后会覆盖掉arr1本身的\0，后面arr2也改变，从而死循环
//my_strcat////////////////////////////////////////////////////////////////////////
//#include<stdio.h>
//#include<assert.h>
//char* my_strcat(char*dest, const char*source)
//{
//    char*ret = dest;
//    assert(dest&&source);
//    while (*dest)
//    {
//        dest++;
//    }
//    while (*dest++ = *source++)  //strcpy
//        ;
//    return ret;
//}
//
//int main()  //  my_strcat
//{
//    char arr1[30] = { 'a', 'b', 'c', 'd', '\0' };
//    char arr2[] = "bit";
//    printf("%s", my_strcat(arr1, arr2));
//    return 0;
//}


//strcmp
//比较方式，依次比较ascii大小，大返回正数，小于返回负数，等于则比较下一位。若全都相等则返回0；
//my_strcmp////////////////////////////////////////////////////////////////
//#include<stdio.h>
//#include<assert.h>
//int my_strcmp(const char*str1, const char*str2)
//{
//    assert(str1&&str2);
//    while (*str1 == *str2)
//    {
//        if (str1 == '\0')
//        {
//            return 0;
//        }
//        str1++;
//        str2++;
//    }
//    if (*str1 < *str2)
//        return -1;
//    else
//        return 1;
//}
//
//int main()  //my_strcmp A1.0 版本 返回固定值（1，0，-1）
//{
//    char* str1 = "aaaa";
//    char* str2 = "bbbb";
//    int ret = my_strcmp(str1, str2);
//    printf("%d\n", ret);
//    return 0;
//}

//#include<stdio.h>
//#include<assert.h>
//int my_strcmp(const char*str1, const char*str2)
//{
//    assert(str1&&str2);
//    while (*str1 == *str2)
//    {
//        if (str1 == '\0')
//        {
//            return 0;
//        }
//        str1++;
//        str2++;
//    }
//    return(*str1 - *str2);
//}
//
//int main()  //my_strcmp B1.0 版本 返回差值
//{
//    char* str1 = "aaaa";
//    char* str2 = "bbbb";
//    int ret = my_strcmp(str1, str2);
//    printf("%d\n", ret);
//    return 0;
//}


//my_strncpy//////////////////////////////////////////////////////
//#include<assert.h>
//char* my_strncpy1(char*str1, const char*str2, int num)//my_strncpy  低级（自创）版本
//{
//    assert(str1&&str2);
//    assert(num > 0);
//    char*start = str1;
//    int n = 0;
//    int len = 0;
//    char *str0 = str1;
//    while (*str0++)   //实计算字符串长度
//    {
//        len++;
//    }
//    while (num--)
//    {
//        n++;
//        if (n <= len)
//            *str1++ = *str2++;
//        else
//            *str1++ = '\0';
//    }
//    return start;
//}
//
//char* my_strncpy2(char*str1, const char*str2, int count)//原版，库函数版
//{
//    assert((count> 0) && str1&&str2);
//    char*start = str1;
//    while (count && (*str1++ = *str2++))
//        count--;
//    if (count)
//        while (--count)
//            *str1++ = '\0';
//    return start;
//}
//
//int main()
//{
//    char arr1[10] = "abcd\0xxx";
//    char arr2[] = "1234";
//    my_strncpy2(arr1, arr2, 8);
//    printf("%s", arr1);
//    return 0;
//}


//my_strncat/////////////////////////////////////////////////////////////////
//#include<assert.h>
//char* my_strncat1(char*str1, const char*str2, int count)
//{
//    assert(count > 0 && *str1&&*str2);
//    char*start = str1;
//    while (*str1)
//        str1++;
//    //while ((count--)&&(*str1++ = *str2++))  //模仿自编
//    //    ;
//    //return start;
//    while (count--)
//        if (!(*str1++ = *str2++))             //库
//            return start;
//}
//
//int main()
//{
//    char arr1[20] = "abcd\0xxxxxxx";
//    char arr2[] = "1234";
//    my_strncat1(arr1, arr2, 8);
//    printf("%s", arr1);
//    return 0;
//}

//strstr////////////////////////////////////////////////////////////////////////////////
//#include<string.h>
//int main()
//{
//    char *p1 = "abcdefabcdef";
//    char *p2 = "def";
//    char* ret = strstr(p1, p2);
//    if (ret == NULL)
//        printf("字串不存在");
//    else
//        printf("%s\n", ret);
//    return 0;
//}

//模拟实现my_strstr////////////////////////////////////////
//#include<assert.h>
//char* my_strstr(const char*str1, const char *str2)
//{
//    char* str11 = (char*)str1;  //受保护的先转换后赋值，类型有所不同
//    char* str21 = (char*)str2;
//    assert(str1&&str2);
//    if (!*str2)
//        return (char*)str1;
//    while (*str1++)//str++一次
//    {
//        str11 = (char*)str1;
//        str21 = (char*)str2;
//        while (*str11++ == *str21++)//引入指针使此循环不影响外界循环，不引的话会改变str的值，混乱
//            ;
//                //while ( *s1 && *s2 && !(*s1-*s2) )s1++, s2++;//这是高级版
//        if (!*--str21)//if (*--str21 == '\0')
//            return (char*)str1;  //str1是受const保护的，直接返回会有警告，所以强制类型转换。
//    }
//    return NULL;
//}
//
//int main()
//{
//    char* p1 = "abcddefdef";
//    char* p2 = "def";
//    char* ret = my_strstr(p1, p2);
//    if (ret == NULL)
//        printf("子串不存在\n");
//    else
//        printf("%s\n", ret);
//    return 0;
//}  
//拓展：KMP算法，更高级，更难理解...


//char * strtok ( char * str, const char * sep );//会自动存储节点记忆，可以下次继续调用
                         //应该是创建了静态变量，不会销毁，下次还能用
//int main()  //基本原理（会用就行）
//{
//    //chj@gduptedu.cn (@ .)     
//    char arr[] = "chj.gdupt@edu.cn";
//    char*p = "@.";//包含即可
//    char buf[1024] = { 0 };
//    strcpy(buf, arr);
//
//    char*ret = strtok(arr, p);
//    printf("%s\n", ret);
//
//    ret = strtok(NULL, p);
//    printf("%s\n", ret);
//
//    ret = strtok(NULL, p);
//    printf("%s\n", ret);
//
//    ret = strtok(NULL, p);
//    printf("%s\n", ret);
//
//    return 0;
//}

//int main()  //strtok常规用法//////////////////////////////////////////////////
//{
//    //点分十进制（ip地址的表示方式）：192.168.123.1  ( . )
//    char arr[] = "192.168.123.1";
//    char*p = ".";
//    char buf[1024] = { 0 };
//    strcpy(buf, arr);    //直接用也行，就是顺便使用strcpy而已
//    char*ret = NULL;
//    for (ret = strtok(buf, p); ret != NULL; ret = strtok(NULL, p))
//    {
//        printf("%s\n", ret);
//    }
//
//    return 0;
//}


//#include<string.h>         //   char* strerror(int errnum);
//#include<errno.h>          // errno  
//int main()
//{
//错误码   错误信息
//strerrer(0) -    No error
//strerror(1) -    operation not permitted
//strerror(2) -    No such file or directory
//...
//strerror(errno)  errno是一个全局的错误码的变量
//当C语言的库函数在执行过程中，发生了错误，就会把对应的错误码，赋值到errno中
//举例如下

//char* str = (char*)strerror(errno);
//printf("%s", str);

//FILE* pf = fopen("test.txt", "r");
//if (pf == NULL)
//    printf("%s\n", strerror(errno));
//else
//    printf("open file success");
//return 0;
//}

//字符分类函数：
//
//函数 如果他的参数符合下列条件就返回真
//iscntrl 任何控制字符
//isspace 空白字符：空格‘ ’，换页‘\f’，换行'\n'，回车‘\r’，制表符'\t'或者垂直制表符'\v'
//isdigit 十进制数字 0~9
//isxdigit 十六进制数字，包括所有十进制数字，小写字母a~f，大写字母A~F
//islower 小写字母a~z
//isupper 大写字母A~Z
//isalpha 字母a~z或A~Z
//isalnum 字母或者数字，a~z, A~Z, 0~9
//ispunct 标点符号，任何不属于数字或者字母的图形字符（可打印）
//isgraph 任何图形字符
//isprint 任何可打印字符，包括图形字符和空白字符
//
//* isupper example */
//#include <stdio.h>
//#include <ctype.h>//int tolower(int c);int toupper(int c);
//int main()
//{
//    int i = 0;
//    char str[] = "Test String.\n";
//    char c;
//    while (str[i])
//    {
//        c = str[i];
//        if (isupper(c))
//            c = tolower(c);
//        putchar(c);
//        i++;
//    }
//    return 0;
//}


//_____________________________________________________________________________________
//内存函数（memcpy,menmove,memcmp,memset)//mem类和strn相似，多了个参数n
//memcpy(内存拷贝)
//void* memcpy(void* destination, const void* source, size_t num);//num是总字节数
//函数memcpy从source的位置开始向后复制num个字节的数据到destination的内存位置。
//这个函数在遇到 '\0' 的时候并不会停下来。
//如果source和destination有任何的重叠，复制的结果都是未定义的。

//memcpy:strcpy进阶版，拷贝所有类型数组
//#include<stdio.h>
//#include<string.h>
//struct S
//{
//    char name[10];
//    int age;
//};
//
//int main()
//{
//    int arr1[] = { 1, 2, 3, 4, 5 };
//    int arr2[5] = { 0 };
//    memcpy(arr2, arr1, sizeof(arr1));
//    for (int i = 0; i < sizeof(arr1) / sizeof(arr1[0]); i++)
//    {
//        printf("%d ", arr2[i]);
//    }
//    struct S arr3[] = { { "张三", 20 }, { "李四", 30 } };
//    struct S arr4[3] = { 0 };
//    memcpy(arr4, arr3, sizeof(arr3));
//    printf("%s,%d  %s,%d", arr4[0].name, arr4[0].age, arr4[1].name, arr4[1].age);
//    return 0;
//}

//memcpy原理：void*,分隔成最小单位字节，无视类型，直接拷贝。
//#include<assert.h>
//#include<stdio.h>
//void my_memcpy(void*dest, const void* src, size_t num)
//{
//    void* ret = dest;
//    assert(dest&&src);
//
//    while (num--)//先使用后减减
//    {
//        *(char*)dest = *(char*)src;//source
//        //(char*)dest++;//void 不能++
//        ++(char*)dest;
//        ++(char*)src;
//    }
//    return ret;
//}
//int main()
//{
//    int arr1[] = { 1, 2, 3, 4, 5 };
//    int arr2[5] = { 0 };
//    my_memcpy(arr2, arr1, sizeof(arr1));
//    return 0;
//}

//对于memcpy和memmove（memcpy有些编译器可以处理重叠）
//C语言标准规定
//memcpy只要处理不重叠的内存拷贝就可以
//memmove处理重叠内存的拷贝

//#include<string.h>
//void* my_memmove(void*dest, const void*src, size_t num)
//{
//    void* ret = dest;
//    assert(dest&&src);
//    if ((char*)src - (char*)dest > -num && (char*)src - (char*)dest < 0)//src<dest&&dest<src+num
//    {
//        (char*)dest += num;
//        (char*)src += num;
//        while (num--)
//        {
//            --(char*)dest;
//            --(char*)src;
//            *(char*)dest = *(char*)src;
//        }
//    }
//    else if ((char*)src - (char*)dest < num && (char*)src - (char*)dest>0)//dest<src&&dest>src-num
//    {
//        while (num--)
//        {
//            *(char*)dest = *(char*)src;
//            ++(char*)dest;
//            ++(char*)src;
//        }
//    }
//    else//可以合并，舍去
//        memcpy(dest,src,num);
//    return ret;
//}
//
//int main()
//{
//    int arr1[] = { 1, 2, 3, 4, 5 };
//    int arr2[5] = { 0 };
//    my_memmove(arr1 , arr1+2, 2 * sizeof(arr1[0]));
//    return 0;
//}

//优化（合并归类）
//void my_memmove(void*dest, const void*src, size_t num)
//{
//    void* ret = dest;
//    if (dest < src ) //指针可以直接比较，但是不能直接相减（需要确定类型）
//    {
//        while (num--)
//        {
//            *(char*)dest = *(char*)src;
//            ++(char*)dest;
//            ++(char*)src;
//        }
//    }
//    else
//    {
//        while (num--)
//        {
//            *((char*)dest + num) = *((char*)src + num);
//        }
//    }
//    return ret;
//}
//
//int main()
//{
//    int arr1[] = { 1, 2, 3, 4, 5 };
//    int arr2[5] = { 0 };
//    my_memmove(arr1+2 , arr1, 2 * sizeof(arr1[0]));
//    return 0;
//}

//int memcmp(const void*ptr1 , const void*ptr2 , size_t num)  //一个一个字节比较
//Return Value :<0 ,=0 ,>0

//memset-内存设置  void *memset(void *dest,int c,size_t num)
//c为要设置的字符：charactes to set ; num 为要设置的字节。
//int main()
//{
//    char arr[10] = "0";
//    memset(arr, '#', 10);
//    return 0;
//}

//_____________________________________________________________________________________
//内置类型-C语言自己的数据类型（char,short,int,long,float,double)
//复杂类型-自定义类型：结构体、枚举、联合体

//结构体内存对齐
//练习1
//struct S1
//{
//    char c1;
//    int i;//4<8==4
//    char c2;
//};
//printf("%d\n", sizeof(struct S1));//12==1, 4-8, 9, 9-12(12==4n)
////练习2
//struct S2
//{
//    char c1;
//    char c2;
//    int i;//4
//};
//printf("%d\n", sizeof(struct S2));//8==1,2,4-8,(8==4n)

/* 结构体大小计算方法：
 * 结构体对齐规则：
 * 1.第一个成员在与结构体变量偏移量为0的地址处。（其实就是第一个位置）
 * 2.其他成员变量要对齐到对齐数的整数倍的地址处。
 * （对齐数=编译器默认的一个对齐数与该成员大小的较小值。）
 * （VS中默认为8，有些编译器（如gcc）没有或为1或为其他。）
 * 3.结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍
 * （成员对齐数为成员自身类型大小）
 * 4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，
 * 结构体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。
 * 5.没有对齐数就不用对齐，直接排列。
 *///(对数组而言，对齐数是元素（基本类型大小，如char[5]对齐数还是1）)
//练习3
//struct S3
//{
//    double d;//8==8==8
//    char c;
//    int i;
//};
//printf("%d\n", sizeof(struct S3));//16==8,9,9-12,12-16,(16==8n)
////练习4-结构体嵌套问题
//struct S4
//{
//    char c1;
//    struct S3 s3;//对齐数8（8==8==8）,大小16
//    double d;//8,(8==8==8)
//};
//printf("%d\n", sizeof(struct S4)//32==1，1-8，8-24，24-32（32==8n)

/* 存在内存对齐的原因：
 * 1.平台原因（移植原因）：
 * 不是所有的硬件平台都能够访问任意地址上的任意数据的；
 * 某些硬件平台只能在某些地址处取得特定类型的数据，否则抛出硬件异常。
 * 2.性能原因：
 * 数据结构（尤其是栈）应该尽可能地在自然边界上对齐。
 * 原因在于，为了访问未对齐的内存，处理器需要作两次内存访问，
 * 而对齐的内存访问仅需要一次访问。
 * （空间换时间）如：32位4字节4字节地读取，不对齐则要重新访问。
 */


 //设计结构体（既要满足对齐，又要节省空间）：让占用空间小的成员尽量集中在一起。

 //修改默认对齐数
 //预处理指令 #pragma pack(4)  //设置默认对齐数为4    //一般为1，2，4，8，2^n
 //#pragma pack()              //取消默认对齐数，还原成默认设置

 //example
//#include <stdio.h>
//#pragma pack(8)//设置默认对齐数为8
//struct S1 
//{
//    char c1;
//    int i;
//    char c2;
//};
//#pragma pack()//取消设置的默认对齐数，还原为默认
//#pragma pack(1)//设置默认对齐数为1
//struct S2
//{
//    char c1;
//    int i;
//    char c2;
//};
//#pragma pack()//取消设置的默认对齐数，还原为默认
//int main()
//{
//    //输出的结果是什么？
//    printf("%d\n", sizeof(struct S1));//12
//    printf("%d\n", sizeof(struct S2));//6
//       return 0;
//}
 //(目前不知道设置多少比较好）

//偏移量计算函数：
//offsetof();//<stddef.h>宏,未学，最后再学。
//计算结构体中某变量相对于首地址的偏移，并给出说明。
//用法：
//printf("%d", sizeof(struct S1.c1));//特殊：参数为类型
//printf("%d", sizeof(struct S1.i));
//printf("%d", sizeof(struct S1.c2));


//位段（二进制位）：就是在位上存储

//位段成员类型：整型家族：int类，char类少用。无float,double.
//位段的成员名后边有一个冒号和一个数字。

//struct S
//{
//    int a : 2;  //限定2个比特位（在肯定数据不会超出4 D（100）B 的情况下
//    int b : 5;  //限定5个比特位
//    int c : 10; //限定10个比特位
//    int d : 30; //限定30个比特位
//};//总共47个比特位，理论47<4*12=48，6个字节空间可存放，实际也有对齐（VS为8字节）

//位段的内存分配
//1.位段的空间上是按照需要以4个字节（int)或者1个字节（char)的方式来开辟的。（...如，int一次开辟4字节32比特位来使用，不够再开辟）
//2.位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。（网络编程涉及，网络传输数据包，）
//（原因：没有C语言标准，各编译器有所不同。）
//位段不能大于32（32位机器），16位则不能大于16位
//不给定位段的默认为字节数

//example
//struct S
//{
//    char a : 3;
//    char b : 4;
//    char c : 5;
//    char d : 4;
//};
//int main()
//{
//    struct S s = { 0 };
//    s.a = 10;// 1010 |  010
//    s.b = 20;//10100 | 0100
//    s.c = 3; //  011 |00011
//    s.d = 4; //  100 | 0100
//    return 0;
//}
/*
//模拟，先开辟1个字节8个比特位(以VS编译器为例，VS每个字节从右往左。）
0 | 0 0 0 0 | 0 0 0     0 0 0 | 0 0 0 0 0     0 0 0 0 | 0 0 0 0 
0 | 0 1 0 0 | 0 1 0     0 0 0 | 0 0 0 1 1     0 0 0 0 | 0 1 0 0 
舍|    b    |   a         舍  |    c              舍  |      d      
    2    |     2             0   |    3          0    |     4   (十六进制）
内存显示：22 03 04
*/
//位段的跨平台问题：
//1.int位段被当成有符号数还是无符号数没有规定（最高位1当成什么不确定）
//2.位段中最大位的数目不能确定（16位机器最大为16，32位机器最大32。写成27，在16位机器会出问题
//3.位段中的成员在内存中从左向右分配，还是从右向左分配没有规定(00001111还是11110000)
//4.当一个结构体包含两个位段，第二个位段成员比较大，无法容纳第一个位段剩余的位时，不确定是舍弃剩余位还是利。
//（按类型字节开辟的位不够放时，VS中是舍弃）

//总结，跟结构体相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。


//_____________________________________________________________________________________
//枚举类型（无对齐）
//顾名思义就是一一列举，把可能的取值一一列举，如周一到周日，性别，月份

//枚举类型定义
//example
enum Day//枚举的类型 //星期
{
    //枚举的可能取值(语法决定是整型，不能是浮点型)
    Mon,
    Tues,
    Wed,
    Thur,
    Fri,
    Sat,
    Sun
};
enum Sex//性别
{
    //枚举的可能取值(常量--又叫枚举常量）
    //常量默认值为：
    MALE,   //0
    FEMALE, //1
    SECRET  //2
};
//运用

enum Color
{
    //常量（虽然不能赋值）可以初始化：
    //RED = 2, 
    //GREEN = 4,
    //BLUE = 8,
    RED = 1,//给前面赋值后，后面没赋值的自动在此基础上+1 
    GREEN, //自动加一为2
    BLUE   //自动加以为3
};

//与预处理比较
//#define RED 0   //这里没有类型，而枚举有类型，有类型就会有限制（类型检查），更加严谨
//#define GREEN 1  //在执行时会直接替换
//#define BLUE 2
//首先C语言源代码处理：预编译-->编译-->链接-->可执行程序
//预编译过程为：执行预处理指令，去掉注释等冗余的东西
//预处理在执行时会直接替换

/*枚举的优点
* 1.增加代码的可读性和可维护性
* 2.与#define定义的标识符比较，枚举有类型，有类型就会有限制（类型检查），更加严谨
* 3.防止了命名污染（封装), 有{}括起来。不会和{}外标识符起冲突。
* 4.便于调试（预处理复杂的话很难看）
* 5.使用方便，一次可以定义多个常量（#define的话每次都要#define）
*/

//int main()//枚举应用
//{
//
//    enum Sex s = MALE;//创建变量s并初始化成MALE，
//    s = FEMALE;//赋值FEMALE（只能赋类型中有的
//    //s = xxx;//error    //赋值只能是枚举的可能取值。不能是其他
//
//    enum Color c = BLUE;
//
//    printf("%d , %d , %d\n", RED, GREEN, BLUE);//常量可以直接打印
//    printf("%d , %d , %d\n", MALE, FEMALE, SECRET);
//
//    //enum Color d = 2;//不能这样赋值，类型不同，2是int，d是num Color类型。虽然c可以运行，但cpp不行，更严格
//
//    return 0;
//}

//枚举大小计算：与赋值的类型相同，枚举内的常量都是整型。emun Color d = RED;
//printf("%d\n",sizeof(d));//结果为4;



//_____________________________________________________________________________________
//联合--联合体--共用体
//联合也是一种特殊的自定义类型，类似结构体包含一系列成员，特征是这些成员公用同一块空间（所以联合也称共用体）

//特点：共用一块内存空间，大小至少为最大成员的大小（至少得有能力保存最大的那个成员）

//运用举例：
//int check_sys()//原理
//{
//    ////方法一：
//    //int a = 1;
//    //return *(char*)&a;//为什么不直接（char）a，因为读值的方法与排法无关，我们要的是地址存放的方式。
//    ////所以转换地址类型（char*）
//
//    union Un//方法二：共用体(优化：测试大小端基本只用一次，所以可以设置匿名联合体，创建一次变量足够，union{char c;int i;}u;)
//    {
//        int i;
//        char c;
//    }u;//原理：i，c地址相同，空间内存放的数据相同，根据类型不同读取的位数不同，从而使多值可以实现
//    u.i = 1;//由于读取方向固定(从低地址向高地址），小端则01 00 00 00，大端则00 00 00 01
//    return u.c;//如果小端则为1，大端则为0.
//    //低...[字节][][][][][01][00][00][00][][][][][][][][]...高
//    //低...[字节][][][][][00][00][00][01][][][][][][][][]...高
//}//栈的内存开辟是从高地址往低地址段开辟,但是读取内存都是从低地址往高地址读取的
//
//
//int main()
//{
//    int ret = check_sys();
//    if (1 == ret)
//        printf("小端\n");
//    else
//        printf("大端\n");
//    return 0;
//}

//联合体大小的计算
//1.联合的大小至少是最大成员的大小
//2.当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。
union Un
{               //VS默认对齐数为8；
    char arr[5];//大小为5，类型对齐数为1，最小对齐数为1，（相当于5个char、对齐数还是1）
    int i;      //大小为4，类型对齐数为4，最小对齐数为4
}u;//最大成员大小不是最大对齐数的整数倍，所以要对齐到整数倍-> 8
printf("%d\n", sizeof(u));//8

//_____________________________________________________________________________________
//通讯录实现（结构体）


//_____________________________________________________________________________________
//动态内存分配（都在堆上开辟）
//标准库<stdlib.h>

//allocates(划分，分配)  memory(内存) block（区域、块） insufficient（不足，不够）
//available(可用，可获得，可找到） enough(充足，足够地）

//1.malloc（开辟空间）memory allocation


//void *malloc(size_t size);//返回值为任意类型指针，需要转换。（部分编译器自动转换）
//malloc返回一个任意类型的指向开辟的空间(此空间中的初始值不确定)的地址或NULL指针（当可用内存不足时）
//如果参数size为0，malloc的行为是标准未定义的，取决于编译器。

//产生背景：不能动态开辟。
//（变长数组可以实现，C99支持，但只有部分编译器支持。变长数组n可以为变量）

//example 
//int *p = (int*)malloc(10 * sizeof(int));//强制类型转换是好习惯
//if (p == NULL)printf("%s\n", strerror(errno));<string.h><errno.h>
//else
//{
//    for (int i = 0; i < 10; i++) printf("%d",*(p + i) = i);
//}

//2.free（主动释放、回收空间）
//注：free后必须初始化指针p=NULL等；
//memblock(内存块）

//void free(void *memblock);<stdlib.h>

//产生背景：有借有还，当动态申请的空间不再使用的时候，返还给操作系统，释放内存。
//内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，
//造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

//运用场景：在空间不使用的时候，程序后续还有需要开辟空间的行为时，主动释放空间.
//(当程序结束时，malloc开辟的空间会自动释放回收)
//1.如果参数p==NULL,则什么都不做，放心（防多次释放）
//2.如果参数p指向的空间不是动态开辟（malloc那些）的，那free函数的行为是未定义的。
//如数组，最好不要做


//example-续上
//free(p);//虽然p所指向的空间（malloc开辟的空间）被释放了，但是p还是指向那片空间
//（p存放的指针没改变，只是内存可以重新被系统分配了）
//p = NULL;//需要将p置空，以防止野指针，破坏系统。


//3.calloc['kælɒk](动态内存分配并清零) clear allocation
//malloc修改版
//Allocates an array in memory with element initializad to 0;
//分配    一个数组 到内存   ， 并  元素   初始化 成 0；

//void *calloc(size_t num, size_t size);   <stdlib.h>
//num:number of element(元素个数）  size：Length in bytes of each element (每个元素的字节长度） 

//calloc returns a pointer to the allocated space.
//The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object.
//To get a pointer to a type other than void, use a type cast on the return value.

//suitably（适当地）   aligned（对齐，排整齐，使一致） cast（制造，转换） guaranteed（保证）
//object(对象）

//calloc 返回指向已分配空间的指针。
//返回值所指向的存储空间保证与任何类型的对象的存储适当对齐。
//若要获取指向 void 以外的类型的指针，请在返回值上使用强制转换类型。

//与malloc区别在于效率和参数。根据效率选用

//int main()  //内存函数使用规范
//{
//    int *p = (int*)calloc(10, sizeof(int));//参数：多少个元素，每个元素的字节大小
//    if (p == NULL) printf("%s\n", srterror(errno));
//    else
//    {
//        for (int i; i < 10; i++)
//        {
//            printf("%d", *(p + i));
//        }
//    }
//    free(p);
//    p = NULL;
//    return 0;
//}


//realloc(动态内存调整、调整动态开辟内存的大小) reset allocation
//re 是一个前缀，有重新，再一次的意思

//void *realloc(void *memblock,size_t size);//先前开辟的的内存块的指针，新的大小，单位为字节。

//previously(先前的)    in bytes(单位为字节)

//使用注意事项：
//1.如果p指向的空间之后有足够的空间可以追加，则直接追加，返回原来地址p
//2.如果p指向的空间之后没有足够的内存空间可以追加，则realloc函数会重新寻找一块新的内存区域开辟一块满足需求的空间，
//并且把原来内存中的数据拷贝过来（追加的空间为随机值），释放旧的内存空间，最后返回新开辟的空间的地址（所以地址改变不用大惊小怪）。
//3.如果需要开辟的空间过大（内存不足），则返回空指针NULL。
//总结：需要一个新指针变量来接受realloc函数的返回值。
//realloc函数的出现让动态内存管理更加灵活

//int*ptr = realloc(p, INT_MAX);
//if (ptr != NULL)
//{
//    p = ptr;
//    //操作
//    //...
//}
//else
//{
//    printf("%s\n", srterror(errno));
//    exit(EXIT_FAILURE);
//}
//free(p);
//p = NULL;
//

//realloc实现malloc
//int *p = realloc(NULL, 40);//等价malloc(40)


//_____________________________________________________________________________________
//常见的动态内存错误

//1.对NULL指针进行解引用操作（没有规范操作）
//{
//    int*p = (int*)malloc(INT_MAX);
//    *p = 20; //如果p的值是NULL,就会有问题
//    free(p);    //如果p的值是NULL,就会有问题
//}
//2.对动态开辟空间的越界访问（假死：明显现象是程序奔溃，卡死，多次才能关闭）
//如果新手，建议多个写一个保护语句;熟练：老实把边界算好。
//3.对非动态开辟内存使用free释放（假死）
//int a = 0; int *p = &a; free(p); a在栈区，free对堆区操作->bug;
//4.使用free释放一块动态开辟内存的一部分（还是不建议自增++自减--啊！，老实用p + i最好）
//*p++ = i; free(p); p = NULL; （假死）
//5.对同一块动态内存多次释放
//free(p);
////...业务执行很多后忘记
//free(p);
////避免方法
//free(p);
//p = NULL; (好习惯)
//free(p);
//6.动态开辟内存忘记释放（内存泄露）memory leak
//void test()
//{
//    int *p = (int*)malloc(100);//p是只作用在test内的临时变量
//    if (NULL != p){
//        *p = 20;
//    }
//}
//int main()
//{
//    test();//内存泄漏无法挽回。因为p在函数调用结束后就销毁了，找不到泄露的地址了。
//    while (1);
//}

//常见内存问题
//#include<stdio.h>
//void GetMemory(char*p) //临时拷贝（接收的是NULL）
//{
//    p = (char*)malloc(100);//开辟空间
//}//1.内存泄露
//void Test(void)
//{
//    char*str = NULL;
//    GetMemory(str);//传的是值（&str才是址）（传的是NULL)
//    strcpy(str, "hello world");//2.对空指针解引用
//    printf(str);
//}
//int main()
//{
//    Test();
//    return 0;
//}
////改正1
//void GetMemory(char**p) 
//{
//    *p = (char*)malloc(100);
//}
//void Test(void)
//{
//    char*str = NULL;
//    GetMemory(&str);
//    strcpy(str, "hello world");
//    printf(str);
//
//    free(str);
//    str = NULL;
//}
////改正2
//void GetMemory(char*p) 
//{
//    p = (char*)malloc(100);
//    return p;
//}
//void Test(void)
//{
//    char*str = NULL;
//    str = GetMemory(str);
//    strcpy(str, "hello world");
//    printf(str);
//    free(str);
//    str = NULL;
//}

//问题合并总结
//void GetMemory1()
//{
//    int a = 10;   //栈区空间
//    return &a;
//}                  //销毁-随机值
//void GetMemory()
//{
//    static int a = 10;//静态区空间
//    return &a;        
//}                      //不会销毁
//void GetMemory()
//{
//    int*p = (int*)malloc(4);//堆区空间
//    return p;          
//}                    //不会销毁


//柔性数组  C99实现   就是结构体中包含了一个大小未指定的数组
//flexible array 结构体中的最后一个元素允许是未知大小的数组（只有在最后才允许不给定大小）
//特点：
//1.结构中的柔性数组成员前面必须至少一个其他成员。
//2.sizeof返回的这种结构大小不包括柔性数组的内存。
//3.包含柔性数组成员的结构用malloc函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。

//优势：
//1.方便内存释放（只开辟一次，只用一次free）
//如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给
//用户。用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你
//不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好
//了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉
//2.访问速度快。（）
//连续的内存有益于提高访问速度，也有益于减少内存
//struct S1
//{
//    int n;//这个n可以用来控制内存分配的大小
//    int arr[];//大小不指定
//    //n的空间{ [][][][] | [][][][][][][][]...自定义开辟 }
//};
//struct S2//[]和[0]一样的，只作演示
//{
//    int n;
//    int arr[0];
//    //      { [][][][] | [][][][][][][][]... }
//};
//int main()
//{
//    struct S1 s1;
//    struct S2 s2;
//    printf("%d\n", sizeof(s1));//结果都是4
//    printf("%d\n", sizeof(s2));//4
//    // 虽然arr[],arr[0],会报警告，但是能跑过去，等用起来就不会警告了
//    //使用方法：
//    struct S1 *ps1 = (struct S1 *)malloc(sizeof(ps1->n) + 5 * sizeof(int));
//    struct S2 *ps2 = (struct S2 *)realloc(NULL, 24);//realloc可以实现malloc
//    ps1->n = 0; ps2->n = 0;
//    int i = 0;
//    for (i = 0; i < 5; i++)
//    {
//        ps1->arr[i] = i;
//        ps2->arr[i] = i;
//        





//("%d ", ps1->arr[i]);// 0 1 2 3 4
//        printf("%d ", ps2->arr[i]);// 0 1 2 3 4
//    }//柔性数组开辟成功
//    printf("\n");
//    struct S1 *ptr1 = (struct S1 *)realloc(ps1, 24 + 4 * 5);//不够再加
//    struct S2 *ptr2 = (struct S2 *)realloc(ps2, 24 + 4 * 5);
//    if (ptr1 != NULL&&ptr2 != NULL)//非空才能使用
//    {
//        ps1 = ptr1;//续上
//        ps2 = ptr2;//续上
//    }
//    for (i = 5; i < 10; i++)
//    {
//        ps1->arr[i] = i;
//        ps2->arr[i] = i;
//    }
//    for (i = 0; i < 10; i++)
//    {
//        printf("%d ", ps1->arr[i]);//0 1 2 3 4 5 6 7 8 9
//        printf("%d ", ps2->arr[i]);//0 1 2 3 4 5 6 7 8 9
//
//    }
//
//    free(ps1); free(ps2);//释放
//    ps1 = NULL; ps2 = NULL;//置空
//    return 0;
//}

//模拟实现柔性数组
//struct S{
//    int n;
//    char *arr;  {[][][][]}---（[]其他空间[]）----[][][][]....
//};                             不连续
//
//int main(){
//    struct S *ps = malloc(sizeof(struct S));
//    ps->arr = malloc(5 * sizeof(int));
//    int i = 0;
//    for (i = 0; i < 5; i++){
//        ps->arr[i] = i;
//    }
//    for (i = 0; i < 5; i++){
//        printf("%d ", ps->arr[i]);
//    }
//    int*ptr = realloc(ps->arr, 10 * sizeof(int));
//    if (ptr != NULL){
//        ps = ptr;
//    }
//    for (i = 5; i < 10; i++){
//        ps->arr[i] = i;
//    }
//    for (i = 0; i < 10; i++){
//        printf("%d ", ps->arr[i]);
//    }
//    free(ps->arr);//我开辟了多少个，检查malloc
//    free(ps);//先释放arr,再释放ps，不然内存泄露
//    return 0;
//}


//拓展：                         先（读取）
//寄存器                     []  ↑--- →cpu（计算）
//高速缓存-cache           [  ]  |    
//内存                 [      ]  |
//硬盘            [           ]  | 后

//局部性原理：（每次读取会取一部分“连续”空间）
//局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。
//解释：柔性数组空间连续，读取速度快。不连续的要多次读取



//_____________________________________________________________________________________
//文件操作（讨论的是数据文件）
//磁盘上的文件是文件
//在程序设计中，一般分为两种：程序文件、数据文件

//程序文件：
//源程序文件（写的代码，后缀为.c），目标文件（windows环境后缀为.obj），可执行程序（windows环境后缀为.exe）。

//数据文件：程序文件操作的文件

//以前所处理数据的输入输出是以终端为对象的，即终端的键盘输入数据，运行结果输出到显示器上

//文件操作，信息输出到磁盘上，需要时才从磁盘读取，输入到内存。

//文件名：(文件标识)
//文件名包含3部分：文件路径+文件名主干+文件后缀
//如：             C:\code\     test     .txt
//文件标识常被称为文件名

//文件类型：
//根据数据的组织形式，数据文件被称为文本文件或二进制文件。
//文本文件：能看懂的，非乱码的，以ASCII字符的形式存储的文件就是文本文件。
//二进制文件：以二进制的形式存储，不加转换输出（直接打开）到外存显示乱码，就是二进制文件
//
//如10000：
//以ASCII形式：1（00110001） 0（00110000） 0（00110000） 0（00110000） 0（00110000）
//二进制形式 ：00 00 27 10
//二进制文件电脑能直读，文本文件要转换


//文件缓冲区
//ANSIC标准采用“缓冲文件系统”处理数据文件，即
//系统自动在内存中为程序中每一个正在使用的文件开辟一块“文件缓冲区”。
//1.从内存向磁盘输出数据时会先送到内存中的“输出缓冲区”，装满缓冲区后才会一起送出到磁盘上。
//2.从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到“输入缓冲区”，充满缓冲区后再从
//缓冲区中逐个将数据送到程序数据区（程序变量等）。
//3.缓冲区地大小根据C编译系统决定地。
//（先充满缓冲区再执行下一步，输出是一起输出，输入是逐个输入）

//文件指针
//1.缓冲文件系统中，关键的概念是“文件类型指针”，简称“文件指针”。
//2.每个被使用的文件都在内存中开辟了一个相应的文件信息区，用来存放文件的相关信息
//（如文件的名字、文件状态、文件位置等）。这些信息保存在一个结构体变量中。
//该结构体类型是由系统自动创建的名为FILE的类型。我们只管用，怎么声明由系统足够了。
//3.FILE转到定义
//4.维护方式：FILE *pf = xxxx;//文件指针变量
//通过pf来维护 ：pf指向文件的文件信息区

//文件的打开和关闭
//说明：打开文件会返回一个FILE*的指针变量指向该文件，相当于建立了指针和文件的关系
//ASCII规定使用open函数来打开文件，fclose来关闭文件。（指针-文件信息区-文件）

//FILE*fopen(const char*FileName, const char*mode);
//int fclose(FILE*stream);

//mode(模式，方式) :Type of "access" "permitted".访问，允许
//A null pointer value "indicates" an error.表示

//（r只读意思是输入，w只写意思是输出）
//mode：           含义                           文件不存在             文件存在
//“r”（只读）    文本文件输入数据               出错
//“w”（只写）    文本文件输出数据               建立新文件             清空
//“a”（追加）    文本文件追加数据               建立新文件
//
//“+”读写
//
//“r+”（读写）   文本文件输入输出数据           出错
//“w+”（读写）   文本文件输出输入数据           建立新文件             清空
//“a+”（读写）   文本文件从头读，追加写         建立新文件

//Expression : (stream != NULL)  //文件打开失败，问题可能是pf，如（pf = NULL）
//(表示、表达式)                  stream一般是指文件指针:流
////“b”二进制
////“rb”（只读）   二进制文件输入数据             出错
////“wb”（只写）   二进制文件输出数据             建立新文件           清空
////“ab”（追加）   二进制文件追加数据             出错
////
////“rb+”（读写）
////“wb+”（读写）
////“ab+”（读写）

//文件路径：
//电脑硬盘E盘下，建文件夹“test”，"test"下建立子文件夹“file”，"file"下建子文件夹“data”,
//电脑资源管理器显示目录  E : \test\file\data
//当前 路径 E : \test\file
//
//1. 相对路径 ，用正斜杠’/‘
//    1.1向上一级目录指向
//    ./    表示当前路径，相当于E:\test\file
//    ../  表示当前路径的上一级路径，相当于E:\test
//    ../../  表示当前路径上上一级路径，相当于E:
//    更多指向上级路径的表示以此类推。
//    1.2 向下一级目录指向
//    ./data  表示当前路径下一级路径，相当于E:\test\file\data
//    ./data/xxx   表示当前路径的下下一级路径，相当于 E:\test\file\data\xxx
//    更多向下指向的路径的表示以此类推。
//
//2.绝对路径，用反斜杠'\'
//   E:\test
//   E:\test\file
//   E:\test\file\data
//
//3.C\C++编程中的相对路径和绝对路径使用
//  C语言中，反斜杠’\‘表示转义字符，所以绝对路径需要如下表示
//  FILE * fp;
//  fp = fopen("E:\\test\\file\\data\\d.txt","r");
//  也可以用相对路径表示，不受转义字符限制：
//  FILE * fp;
//  fp = fopen("E:/test/file/data/d.txt","r");
// 或者，当前路径E:\test\file下，相对路径表示为
//  FILE * fp;
//  fp = fopen("./data/d.txt","r");
//  注意：在使用相对路径和绝对路径时要在头文件上加上direct.h


//相对路径
//fopen("test.txt", a + );
//..表示上一级路径
//.表示当前路径
//fopen("./text,t", a + );
//fopen("../text.t", r);
//
//1.引用上级文件： .. / cover1.jpg
//2.引用同级文件： ./cover1.jpg
//3.引用下级文件： cover / cover1.jpg
//4.引用上上级文件： .. / .. / cover1.jpg
//
//
//2.绝对路径，用反斜杠'\'
//fopen("C:\\Users\\26390\\Desktop\\vs2013\\test1", a + );

//打开文件标准写法
//#include<string.h>
//#include<errno.h>
//int main()
//{
//    FILE *pf = fopen("text.txt", "r");
//    if (pf == NULL)
//    {
//        strerror(errno);
//        return 0;
//    }
//    else
//    {
//
//    }
//
//fclose(pf);
//pf = NULL;
//    return 0;
//}

//关闭文件：（不关闭则无法写入）
//会把test.txt的文件信息区的空间释放掉-- - （指针--文件信息区--文件）
//但指针还在，需要置空
//fclose(pf);
//pf = NULL;

//No such file or directory:没有"这样"的"文件"或"目录"
//directory（目录，文件夹）



//_____________________________________________________________________________________
//文件操作函数：

//fputc://写入一个字符（适用于所有流）
//int fputc(int c,FILE*stream);//stream:流、文件指针
//#include<stdio.h>
//#include<string.h>
//#include<errno.h>
//int main()
//{
//    FILE *pf = fopen("text.txt", "a");//r无反应，w覆写abc，a追加abcabc
//    if (pf == NULL)
//    {
//        printf("%s\n", strerror(errno));
//        return 0;
//    }
//    fputc('a', pf);
//    fputc('b', pf);
//    fputc('c', pf);
//    fclose(pf);
//    pf = NULL;
//    return 0;
//}

//fgetc:读入一个字符 （使用于所有流）Read acharacter from a stream;
//int fgetc(FILE*stream);  //返回读的字符的ascii值，用%c显示
//#include<stdlib.h>
//#include<stdio.h>
//#include<string.h>
//#include<errno.h>
//int main()
//{
//    FILE *pf = fopen("text.txt", "w");//r/r+读出abc，w清空，a+读出abc
//    if (pf == NULL)
//    {
//        printf("%s\n", strerror(errno));
//        return 0;
//    }
//    printf("%c\n", fgetc(pf));
//    printf("%c\n", fgetc(pf));
//    printf("%c\n", fgetc(pf));
//    fclose(pf);
//    pf = NULL;
//    return 0;
//}


//外部设备：键盘，显示器
//键盘：标准输入设备（标准输入流）
//屏幕：标准输出设备（标准输出流）
//他们是一个程序默认打开的两个流设备。Stream流的作用就是操作数据，
//打开程序默认打开三个流：
//stdin   类型都为  FILE*  （FILE* stdin) //键盘
//stdout  类型都为  FILE*   (FILE* stdout)//显示器
//stderr  类型都为  FILE*   (FILE* stderr)
//example
//int main()
//{
//    int ch = fgetc(stdin);//弹出框，输入a
//    fputc(ch, stdout);//显示c
//    return 0;
//}

//fgets:（文本行输入函数）一次操作一行文本(不带换行)


// Remarks
/*
he fgets function reads a string from the input stream argument and stores it in string. fgets reads characters from the current stream position to and including the first newline character, to the end of the stream, or until the number of characters read is equal to n – 1, whichever comes first. The result stored in string is appended with a null character. The newline character, if read, is included in the string. 

fgets is similar to the gets function; however, gets replaces the newline character with NULL. fgetws is a wide-character version of fgets. 

fgetws reads the wide-character argument string as a multibyte-character string or a wide-character string according to whether stream is opened in text mode or binary mode, respectively. For more information about using text and binary modes in Unicode and multibyte stream-I/O, see Text and Binary Mode File I/O and Unicode Stream I/O in Text and Binary Modes.

备注

fgets函数从输入流参数中读取一个字符串，并将其存储在字符串中。fgets从当前流位置读取字符，包括第一个换行符，到流的末尾，或者直到读取的字符数等于n–1，以先到者为准。存储在字符串中的结果附加了一个空字符。换行符（如果已读取）将包含在字符串中。

fgets类似于gets函数；但是，gets将换行符替换为NULL。fgetws是fgets的宽字符版本。

fgetws根据流是以文本模式还是二进制模式打开，分别将宽字符参数字符串读取为多字节字符串或宽字符串。有关在Unicode和多字节流I/O中使用文本和二进制模式的更多信息，请参阅文本和二进制方式中的文本和二进制文件I/O和Unicode流I/O。

*/
//即:fgets按size读,什么都读进去,换行也会(如果最后是回车则会自动换行),并且最后会多一个空间,并放入\0(空字符).
//如"fakljgkljag  \n" -- \n是回车的,也被读进去了,最后隐藏了个\0.
//因为我们要回车才能结束fgets,所以\n不可避免读入,如果要消除回车,只能后续代码处理掉





//Get a string from a stream.从流中获取一个字符串
//char *fgets(char*string, int n, FILE*stream);
//读的时候注意换行，看不见但是也会读取，


//n:要读取的最大字符数 Maximum number of characters to read
//string:storage location for data.数据的存储位置
//buffer一般指缓冲器。 缓冲器在不同的领域有不同的含义。
//在计算机领域，缓冲器指的是缓冲寄存器

//indicate：表示，表明，暗示。
//condition：条件
//determine：确定，决定
//whether（conj）：是否

//example
//int main()
//{
//    char buf[1024] = { 0 };
//    FILE* pf = fopen("text.txt", "r");
//    if (pf == NULL)
//    {
//        printf("%s\n", strerror(errno));
//        return 0;
//    }
//    printf("%s", fgets(buf, 1024, pf));
//    fgets(buf, 1024, pf);
//    printf("%s", buf);
//
//    fclose(pf);
//    pf = NULL;
//    return 0;
//}

//fputs:（文本行输出函数）一次操作一行文本(不带换行)
//int fputs(const char*string, FILE*stream); //Write a string to a stream.
//
//int main()
//{
//    char buf[1024] = { 0 };
//    FILE* pf = fopen("text.txt", "a");
//    if (pf == NULL)
//    {
//        printf("%s\n", strerror(errno));
//        return 0;
//    }
//    fputs("agahaeh", pf);
//    printf("%s", buf);
//
//    fclose(pf);
//    pf = NULL;
//    return 0;
//}


//char *gets(char *buffer); Get a line from the stdin stream.


//puts：Write a string to stdout.（写入一个字符串到显示器：输出流）
//in puts(const char*string);（带换行）
//puts(arr);//直接显示*arr

//putc, putchar,
//Writes a character to a stream(putc, putwc) or to stdout(putchar, putwchar).
//int putc(int c, FILE *stream);
//int putchar(int c);


//等价形式example
//int main()
//{
//    char buf[1024] = { 0 };
//    fgets(buf, 1024, stdin);
//    fputs(buf, stdout);
//    gets(buf);
//    puts(buf);
//    return 0;
//}

//Visual Studio中，未初始化的栈空间用0xCC填充，而未初始化的堆空间用0xCD填充。
//而0xCCCC和0xCDCD在中文GB2312编码中分别对应“烫”字和“屯”字。
//如果一个字符串没有结束符'\0'，输出时就会打印出未初始化的栈或堆空间的内容，这就是大名鼎鼎的“烫烫烫”、“屯屯屯”乱码。


//fprintf（所有输出流）  ≈==  printf （Print formatted output to the standard output stream.）将格式化输出打印到标准输出流。
//（Print formatted data to a stream）将格式化数据打印到流
//int fprintf(FILE *stream, const char *format[, argument]...);
//int printf(               const char *format[, argument]...);

//standard：标准     format:标准 格式化 标准化

//example
//struct S
//{
//    int i;
//    float f;
//    char arr[29];
//};
//int main()
//{
//    struct S s = { 123, 3.14f, "qweqwe" };
//    FILE*pf = fopen("text.txt", "w");
//    if (pf == NULL)
//    {
//        printf("%s\n", strerror(errno));
//        return 0;
//    }
//  //printf(     "%d %f %s", s,i, s.f, s.arr);
//    fprintf(pf, "%d %f %s", s.i, s.f, s.arr);//查看文件结果：123 3.140000 qweqwe
//
//    fclose(pf);
//    pf = NULL;
//    return 0;
//}


//fscanf(所有输入流) ≈ == scanf（Read formatted data from the standard input stream.）
//(Read formatted data from a stream.)

//int fscanf(FILE *stream, const char *format[, argument]...);
//int scanf(               const char *format[, argument]...);

//struct S
//{
//    int i;
//    float f;
//    char arr[29];
//};
//int main()
//{
//    struct S s = { 0 };
//    FILE*pf = fopen("text.txt", "r");
//    if (pf == NULL)
//    {
//        printf("%s\n", strerror(errno));
//        return 0;
//    }
//    //scanf(     "%d %f %s", &s.i, &s.f, s.arr);
//    fscanf(pf, "%d %f %s", &s.i, &s.f, s.arr);
//    printf("%d %f %s", s.i, s.f, s.arr);
//    fclose(pf);
//    pf = NULL;
//    return 0;
//}

//小结：
//scanf/printf   是针对标准输入流/标准输出流的 格式化输入/输出语句
//fscanf/fprintf 是针对所有输入流/所有输出流的 格式化输入/输出语句

//sscanf / sprintf
//sprintf 把格式化数据写入到字符串（从变量中）
//sscanf  从字符串中读取格式化的数据（到变量中）
//example
//struct S
//{
//    int i;
//    float f;
//    char arr[29];
//};
//int main()
//{
//    struct S s = { 123, 3.14f, "qweqwe" };
//    struct S tmp = { 0 };
//    char buf[1024] = { 0 };
//    sprintf(buf, "%d %f %s", s.i, s.f, s.arr);
//    sscanf(buf, "%d %f %s", &tmp.i, &tmp.f, tmp.arr);
//    return 0;
//}


//二进制输入
//fwrite（文件）:Writes data to a stream; 写数据到流
//size_t fwrite(const void *buffer, size_t size, size_t count, FILE*stream)

//*buffer :pointer to date to be written指向要写入的数据
//size:item size in bytes 项大小
//count:Maximum number of items to be written 要写的项的最大数
//Retutn Value : fread returns the number of full items actually written; 返回实际写的项的个数。

//struct S
//{
//    int i;
//    float f;
//    char arr[29];
//};

//int main()//二进制写
//{
//    char buf[1024] = { 0 };
//    struct S s = { 123, 3.14f, "qweqwe" };
//    struct S tmp = { 0 };
//    FILE *pf = fopen("text.txt", "wb");
//    if (pf == NULL)
//    {
//        perror("open file test.txt");
//        return 0;
//    }
//    fwrite(&s, sizeof(struct S), 1, pf);
//
//    fclose(pf);
//    pf = NULL;
//    return 0;
//}

//fread(文件) :reads data from astream;
//size_t fread( void*buffer,size_t size,size_t count,FILE*stream);
//buffer:Storage location for data..
//
//Return Value:fread returns the number of full items actually read：返回实际读到的项的个数。
//actually:真实的，实际， item：项，项目，元素

//int main()//二进制读
//{
//    char buf[1024] = { 0 };
//    struct S s = { 123, 3.14f, "qweqwe" };
//    struct S tmp = { 0 };
//    FILE *pf = fopen("text.txt", "rb");
//    if (pf == NULL)
//    {
//        perror("open file test.txt");
//        return 0;
//    }
//    //fwrite(&s, sizeof(struct S), 1, pf);
//    fread(&tmp, sizeof(struct S), 1, pf);
//    printf("%d %f %s", tmp.i, tmp.f, tmp.arr);//123 3.14 qweqwe
//    fclose(pf);
//    pf = NULL;
//    return 0;
//}

//随机读写fseek：根据文件指针的位置和偏移量来定位文件指针
//int fseek(FILE*stream, long int offset, int origin);//即调整文件指针位置
//Moves the file pointer to a specified location.
//specified：具体，指定
//offset:偏移量：正数向右移动，负数向左移动
//origin:文件指针的当前位置，原点，起始，起源，源头
//position:等级位置，定位（立场，高度）  location:位置
//initial：最初，起始。

//SEEK_SET:Beginning of file.                          0
//SEEK_CUR:Current position of file pointer.当前的     1
//SEEK_END:End of file.文件的末尾                      2
//beginning:开头,开始

// 以文件开头为基准，向后偏移 100 字节
//fseek(fp, 100L, 0);
// 以文件结尾为基准，向前偏移 100 字节
//fseek(fp, -100L, SEEK_END);
// 以文件指针当前位置为基准，向后偏移 100 字节
//fseek(fp, 100L, SEEK_CUR);

//Return Value : If successful, fseek returns 0. Otherwise, it returns a nonzero value.
//On devices incapable of seeking, the return value is undefined.
//如果成功，fseek将返回0。否则，它将返回非零值。在无法查找的设备上，返回值未定义。
//文件中有 （起始）↓a b c d e↓(结尾)
//feek(pf,  2, SEEK_SET);//从起始位置开始，向右移动2个偏移量。↓c
//fseek(pf, 2, SEEK_CUR);//从当前位置开始，向右移动2个偏移量。↓e
//feek(pf, -2, SEEK_END);//从当前位置开始，向左移动2个偏移量。↓d


//ftell:返回文件指针相对于起始位置的偏移量 Gets the current position of a file pointer.
//long int ftell(FILE*stream ); 

//Return Value : ftell returns the current file position.
//↓a b c d e Return 0
//a ↓b c d e Return 1
//a b c d ↓e Return 4
//(计数：段，每个字节一段，多少段即偏移多少)


//rewind:Repostion the file pointer to the beginning of a file.重定位文件指针到文件的开头。
//void rewind(FILE*stream);
//Return Value:None.无返回值


//feof
//
//EOF：-1 （在文件结束位置存在，空文件测试直接读入后打印得-1）
//nonzero:非零

//ferror（输出流的错误错误信息）
//Tests for an error on a stream.
//int ferror(FILE *stream);
//Return Value：
//If no error has occurred on stream， ferror returns 0. Otherwise, it returns a nonzero value.
//occurred（occur）：发生，出现                                                  非零值


//perror
//C语言库函数调用失败错误信息打印
//Print an error message.
//void perror(const char *string);
//string：String message to print
//Return Value：None
//message:消息(书面或口头的)信息; 音信; 电邮(或手机)信息
//打印放的字符串"",然后自动加上: （冒号和一个空格）再加错误信息


//7.1 被错误使用的feof
//牢记：在文件读取过程中，不能用feof函数的返回值直接用来判断文件的是否结束。
//而是应用于当文件读取结束的时候，判断是读取失败结束，还是遇到文件尾结束。
//1. 文本文件读取是否结束，判断返回值是否为EOF （ fgetc ），或者NULL （ fgets ）
//例如：
//fgetc 判断是否为EOF .
//fgets 判断返回值是否为NULL .
//2. 二进制文件的读取结束判断，判断返回值是否小于实际要读的个数。
//例如：
//fread判断返回值是否小于实际要读的个数。

//正确的使用：
//文本文件的例子：
//#include <stdio.h>
//#include <stdlib.h>
//int main(void)
//{
//    int c; // 注意：int，非char，要求处理EOF
//    FILE* fp = fopen("test.txt", "r");
//    if (!fp) {
//        perror("File opening failed");
//        return EXIT_FAILURE;
//    }
//    //fgetc 当读取失败的时候或者遇到文件结束的时候，都会返回EOF
//    while ((c = fgetc(fp)) != EOF) // 标准C I/O读取文件循环
//    {
//        putchar(c);
//    }
    //判断是什么原因结束的
//    if (ferror(fp))
//        puts("I/O error when reading");
//    else if (feof(fp))
//        puts("End of file reached successfully");
//    fclose(fp);
//}

//8.4.4 文件读写出错检测
//1. ferror 函数
//在调用各种输入输出函数（putc、getc、fread、fwrite等）出错的时候，除了各自函数返回值可以体现
//出错信息，你还可以调用**ferror(文件指针)** 函数来判断文件调用是否出错。如果 ferror 函数返回
//0 表示一切正常，若 ferror 函数返回一个非 0 值表示出错了。
//注意，ferror 的返回值是动态变化的，每次调用文件读写函数都会改变其值。因此，要使用其返回值就
//要及时。
//1. clearerr 函数
//使用这个函数来清空出错标记。如果某次文件读写出了错误，ferror 函数会返回一个非 0 值，这时调用
//clearerr 函数能够将其返回值清 0。这是手动清 0，你也可以调用其他文件读写函数来改变 ferror 的返
//回值。


//fflush
//Flushes a stream.
//int fflush(FILE *stream);

//缓冲区内容写入磁盘的时机:
//1.缓冲区满了
//2.调用 fclose 关闭文件函数
//如果想要立刻写入磁盘, 可以使用 fflush 函数刷新缓冲区, 将缓冲区中的数据, 写入磁盘中;
//
//fflush returns 0 if the buffer was successfully flushed.The value 0 is also returned in cases in which 
//the specified stream has no buffer or is open for reading only.A return value of EOF indicates an error.
//如果缓冲区被成功刷新，fflush将返回0。如果指定的流没有缓冲区或仅打开以供读取，也会返回值0。EOF的返回值表示错误。
//
//fflush只是用于立刻输出缓冲区内容的, 它并不会抛弃缓冲区内容, 所以用fflush来清理输入缓冲区本身是错误的。

//fflush 函数可以实时将缓冲区中的数据写入磁盘中, 强烈不推荐频繁大量调用该函数,
//读写磁盘速度很慢, 浪费性能, 浪费时间
//影响磁盘寿命



//______________________________________________________________________________
//ascii（American Standard Code for information interchange)
//interchange=交换
//美国只有128个字符，二进制只有7位，不满足一个字节，为了方便，首位加了个0使满足
//一个字节。00000000=0~ 01111111=127 对美国佬完全够用


//对中国，不够用，自己编码GBK（汉字内码扩展规范，国标）
//·汉字编码字符集，包含了两万多个汉字等字符，GBK中一个中文字符编码成两个字节的形式存储（2^15=32768）
//~GBK也兼容了ASCII字符集
//GBK规定：汉字的第一个字节的第一位必须是1.（ASCII是0），以此区分（两字节识别）
//（GBK：汉字占2字节，英文、数字占1个字节）


//为兼容各国编码：国际组织编译万国码
//Unicode字符集（统一码，也叫万国码）
//历史：
//UTF-32:四个字节表示一个字符，有容乃大的思想，不过太奢侈，占存储空间，通信效率变低！

//UTF-8:
//·是Unicode字符集的一种编码方案，采取可变长编码方案，共分四个长度区：1个字节，2个字节，3个字节，4个字节。
//·英文字符、数字等只占1个字节（兼容标准ASCII编码），汉字字符占用3个字节。

//UTF-8编码方式（二进制）
//0xxx-xxxx（ASCII码，英文字符和阿拉伯数字，直接使用0开头）
//110x-xxxx 10xx-xxxx（两个字节的第一个字节是110开头，第二个字节是10开头）
//1110-xxxx 10xx-xxxx 10xx-xxxx（三个字节：汉字。）
//11110-xxx 10xx-xxxx 10xx-xxxx 10xx-xxxx（四字节）
//（汉字占3个字节，英文、数字占1个字节）


//example:
//a我m
//a ：97        |   01100001
//我：25105     |   110    001000     010001
//m:  109       |   01101101
//a和m直接用ascii
//我：先放010001，放在最后，10-010001
//-----然后放001000 ，放第二个10-001000
//-----最后放第一个 1110 -0-110（放最后，空位补0）


//·技术人员都应该采用utf-8编码
//·字符编码时使用的字符集，和解码时使用的字符集必须一致，否则会出现乱码
//·英文，数字一般不会乱码，因为很多字符集都兼容了ASCII编码




//______________________________________________________________________________
//程序的翻译环境和执行环境
//在ANSI C的任何一种实现中，存在两个不同的环境。
//·第一种是翻译环境，在这个环境中源代码被转换成可执行的机器指令。
//·第二种是执行环境，它用于实际执行代码。

//                                             --
//源文件----->编译器----->目标文件-----｜      编
//源文件----->编译器----->目标文件-----｜      译
//···     >编译器-----> ··· -----｜      环
//源文件----->编译器----->目标文件-----｜      境
//                                     ↓      
//链接库----->链接器<------------------｜      --
//               ｜                            运
//               ↓                            行
//           可执行程序                        环
//                                             境
//任何一个源文件都是一个编译单元               --

//obj----object（对象）--目标文件
//lib---Libraries--------库文件--链接静态库
//编译，生成obj，链接，生成可执行


//翻译环境----------------------

//细分：预编译---编译---汇编--目标文件---链接---可执行程序

//预编译过程：（gcc：-E）text.i
//1·头文件的包含   #include  将头文件拷贝一份进去
//2·注释删除：用空格替换
//3·#difine 预处理，将宏定义的值替换。
//总结：文本层次操作
//#define STR "hehe"  //字符串
//#define MAX 100     //常量
//#define reg register   //关键字
//#define do_forever for(;;)   //符号替换代码
//如果定义的stuff过长 ，可以分为几行写，除了最后一行外，每行的后面都加一个反写杠（续行符）
//#define xxx   printf("%sfafgagahg\
//                       datejalgkal\
//                       fahk           \
//                                      )
//#define STR printf("absffag\
//fajkhga\
//ahfahkfd")
//int main()
//{
//    STR;
//    return 0;
//}


//编译过程:（gcc：-S） text.s
//把C语言代码翻译成汇编代码
//1·语法分析
//2·词法分析：编译原理--简单了解可选择《程序员的自我修养》
//3·语义分析
//4·符号汇总

//汇编过程：（gcc：-c）text.o（.obj）
//把汇编代码转成二进制指令
//1·形成符号表

//链接过程：
//1·合并段表（将相同格式的文件按一定规则合并）：实现不同文件之间联系和链接
//2·符号表的合并和重定位
//常见错误、报错：LNKxxxx（


//运行环境-------------------------------
//1·程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立环境中，程序的载入必须由手工安排，
//也可能是通过可执行代码置入只读内存来完成。
//2·程序的执行main函数开始。
//3·开始执行后，程序将使用一个堆栈（stack），存储函数的局部变量和返回地址。程序同时可以使用
//静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值
//4·终止程序。正常终止main函数；也有可能意外终止（会有意外）


//______________________________________________________________________________
//预处理（编译）详解
//约定：宏用大写 

//命名约定
//一般来讲函数的宏的使用语法很相似。所以语言本身没法帮我们区分二者。
//那我们平时的一个习惯是：
//把宏名全部大写
//函数名不要全部大写

//__FILE__          //进行编译的源文件名字
//__LINE__          //当前执行的行号
//__DATE__          //文件被编译的日期（当前执行日期）   
//__TIME__          //文件被编译的时间（当前执行时间）
//__FUNCTION__      //当前编译的函数名
//__STDC__          //如果编译器遵循ANSI C，其值为1.否则无定义。（用来判断编译器是否是标准C：VS中无定义）



//int main()
//{
//    int i = 0;
//    int arr[10] = { 0 };
//    printf("file:%s    line:%d    date:%s   time:%s\n",__FILE__,__LINE__,__DATE__,__TIME__);
//    printf("function:%s\n", __FUNCTION__);
//    return 0;
//}


//#开头的都是预处理指令  macro
//宏的声明方式：
//#define name(parament-list) stuff其中的parament-list是一个由逗号隔开的符号表，他们可能出现
//在stuff中。
//注意：参数列表的左括号必须与name紧邻，如果两者之间有任何空白存在，参数列表就会被解释为stuff
//的一部分。
//example   


//#define SQUARE(X) X*X
//int ret = SQUARE(5);//25
//int ret = SQUARE(5 + 1);//5+1*5+1==11(注意是替换过去的)
//改进
//#define SQUARE(X) (X)*(X)
//int ret = SUUARX(5 + 1);//36
//用于数值表达式进行求值的宏定义都应加上括号，避免出现疏忽
//宏可以传给另一个宏，但是没有递归
//字符串常量的内容不被搜索（替换）//"MAX"不被替换


//#和##
//char* p = "hello ""bit\n";
//printf("hello"," bit\n");    //hello bit
//printf("%s", p);             //hello bit

//我们发现字符串是有自动连接的特点的。
//1. 那我们是不是可以写这样的代码？：
//#define PRINT(FORMAT, VALUE)\
//printf("the value is "FORMAT"\n", VALUE);
//这里只有当字符串作为宏参数的时候才可以把字符串放在字符串中。

//1. 另外一个技巧是：
//使用# ，把一个宏参数变成对应的字符串。
//#:将右值X变成"X"
//printf("hello world");     //hello
//printf("hello""world");    //hello
//printf("hel""lo""world");  //hello
//由无法替换常量字符串---引出，实现替换常量字符串功能
//#define PRINT(X) printf("the value of"#X"is %d\n",X);
//等价于printf("the value of""X""is %d\n", X);


//##:将左右连接
//##可以把位于它两边的符号合成一个符号。
//它允许宏定义从分离的文本片段创建标识符。
//#define ADD_TO_SUM(num, value) \
//sum##num += value;
//ADD_TO_SUM(5, 10);//作用是：给sum5增加10.
//注：这样的连接必须产生一个合法的标识符。否则其结果就是未定义的。
//#define CAT(X<Y) X##Y
//printf("%d\n", CAT(Class, 5)); == printf("%d\n", Class5)


//少用有副作用的宏表达式，自增自减->容易错误
//#define MAX(X,Y) ((X)>(Y):(X)>(Y))
//int a = 10; int b = 11;
//int max = MAX(a++, b++); 
//printf("%d\n", max);//12
//printf("%d\n",   a);//11
//printf("%d\n",   b);//13


//那为什么不用函数来完成这个任务？
//原因有二：
//1. 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以宏比
//函数在程序的规模和速度方面更胜一筹。
//2. 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之
//这个宏怎可以适用于整形、长整型、浮点型等可以用于>来比较的类型。宏是类型无关的。
//当然和宏相比函数也有劣势的地方：
//1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序
//的长度。
//2. 宏是没法调试的。
//3. 宏由于类型无关，也就不够严谨。
//4. 宏可能会带来运算符优先级的问题，导致程容易出现错。
//宏有时候可以做函数做不到的事情。比如：宏的参数可以出现类型，但是函数做不到。
//#define MALLOC(num, type)\
//(type *)malloc(num * sizeof(type))
//int *p=MALLOC(10, int);//等价(int *)malloc(10 * sizeof(int));

//宏是复制，函数是调用
//宏执行更快
//宏不易调试
//宏不可以递归，函数可以


//#define MAX xxxxx
//#undef MAX  //取消定义
//之后就调用不了MAX了
//如果现存的一个名字需要被重新定义，那么他的旧名字首先要被移除。

//3.4 命令行定义
//许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。
//（高级，仅了解）

//条件编译
//#ifdef
//#endif

//#include <stdio.h>
//#define DEBUG  //如果DEBUG有定义，则
//int main()
//{
//    int i = 0;
//    int arr[10] = { 0 };
//    for (i = 0; i<10; i++)
//    {
//        arr[i] = i;
//#ifdef DEBUG
//        printf("%d\n", arr[i]);//为了观察数组是否赋值成功。
//#endif //配对结束标志
//    }
//    return 0;
//}

//#ifdef 常量表达式（值为真/假）  //真执行，假不执行（删掉）
//       //
//#endif

//#if defined(DEBUG)  ==   #ifdef DEBUG
//#endif

//#if !defined(DEBUG)  ==   #ifndef DEBUG
//#endif

//4.嵌套指令
//#if defined(OS_UNIX)//unix系统执行
//    #ifdef OPTION1
//        unix_version_option1();
//    #endif
//    #ifdef OPTION2
//        unix_version_option2();
//    #endif
//#elif defined(OS_MSDOS)//windows执行
//    #ifdef OPTION2
//        msdos_version_option2();
//    #endif
//#endif


//多分支条件编译
//2.多个分支的条件编译
//#if 常量表达式
////...
//#elif(else if) 常量表达式
////...
//#else
////...
//#d=endif


//3.6 文件包含
//我们已经知道， #include 指令可以使另外一个文件被编译。就像它实际出现于#include 指令的地方
//一样。
//这种替换的方式很简单：
//预处理器先删除这条指令，并用包含文件的内容替换。
//这样一个源文件被包含10次，那就实际被编译10次。

//解决头文件被多次引用：
//1·条件编译。
//每个头文件的开头写：
//include"test.h":
//#ifndef TEST_H
//           #define TEST_H
//                  //头文件的内容
//#endif
//
//2·#pragma once


//""    查找策略：先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标
//准位置查找头文件。如果找不到就提示编译错误。

//<>    查找策略：直接在标准头文件路径查找，如果找不到就提示编译错误。

//Linux环境的标准头文件的路径： / usr / include
//VS环境的标准头文件的路径：C : \Program Files(x86)\Microsoft Visual Studio 12.0\VC\include

//对于库文件也可以使用""的形式包含。效率低。
//但是这样做查找的效率就低些，当然这样也不容易区分是库文件还是本地文件了。



//______________________________________________________________________________
//偏移量 offsetof 
//size_t offsetof(structName, memberName);
//<stddef.h>

//#include<stddef.h>
//struct S
//{
//	char c1;
//	int a;
//	char c2;
//};
//int main()//二进制读
//{
//	printf("%d\n", offsetof(struct S, c1));
//	printf("%d\n", offsetof(struct S, a));
//	printf("%d\n", offsetof(struct S, c2));
//	return 0;
//}

//模拟实现offsetof
#define OFFSETOF(struct_name,member_name) (int)&(((struct_name*)0)->member_name)
//0开始，按struct_name的内存分配直接计算，不用减去起点，更方便

struct S
{
	char c1;
	int a;
	char c2;
};
int main()//二进制读
{

	printf("%d\n", OFFSETOF(struct S, c1));
	printf("%d\n", OFFSETOF(struct S, a));
	printf("%d\n", OFFSETOF(struct S, c2));
	return 0;
}


多维数组的物理结构
int a[3][4] = { 0,1,2,3,4,5,6,7,8,9,10,11 };
for (int i = 0; i < 3; i++) {
	for (int j = 0; j < 4; j++) {
		printf("a[%d][%d] : %p\n", i, j, &a[i][j]);
	}
}
再C语言中,多维数组都是一维抽象而成的,实际就是连续的多个一维数组.记得这一点,将指针和数组都化作一维来看待,解决这类问题就会简单很多.

证明数组a和&a不同
int a[10] = {0};
a是数组首元素地址,&a是数组的地址

int (*p)[10] = a;  //间接级别不同
int (*p)[10] = &a; //符合


数组与指针的差别证明
int main()
{
	int a[4] = { 1,2,3,4 };
	int* p = &a + 1;
	printf("%d \n", p[-1]); //指针才有的用法: p[-1] == *(p-1)
	return 0;
}

什么时候数组名表示整个数组?
1.sizeof(数组名) //sizeof括号内不能再有其他符号
2.&数组名
只有这两种情况才表示整个数组,其他情况数组名都表示数组的首元素地址,a[0]表示数组首元素(内容)
其他情况都会发生降维,降维成指针.



数组训练
int a[3][4] = { 0,1,2,3,4,5,6,7,8,9,10,11 };
printf("%d\n", sizeof(a)); //二维数组
printf("%d\n", sizeof(a[0][0])); //二维数组第一个元素的第一个元素,即第一个一维数组的第一个元素
printf("%d\n", sizeof(a[0]));    //二维数组的第一个元素,是第一个一维数组,没有降维,16
printf("%d\n", sizeof(a[0] + 1));  //二维数组的第一个元素+1,即降维成第一个一维数组的首元素地址+1.是第一个一维数组的第二个元素的地址.
printf("%d\n", sizeof(*(a[0]+1)));  //第一个一维数组的第二个元素
printf("%d\n", sizeof(a + 1));  //降维成二维数组第一个元素的地址+1,即二维数组第二个元素的地址
printf("%d\n", sizeof(*(a+1)));     //二维数组的第二个元素,即第二个一维数组,没有发生降维,16
printf("%d\n", sizeof(&a[0] + 1));    //理解1:二维数组的第一个元素即第一个一维数组取地址,需要一维数组降维成指针,才能进行取地址,数组降维成指针后,就是数组的首元素地址,首元素地址再取地址就成了一维数组. (编译器不支持再升维成数组)
										//理解2:二维数组的第一个元素取地址,二维数组就已经降维成二维数组的首元素地址,元素取地址,则指针对应的类型是二维数组元素的类型,+1就是加一个元素的大小.即得到二维数组的第二个元素的地址. (这种理解更符合编译器行为)
printf("%d\n", sizeof(*(&a[0]+1))); //什么含义？
printf("%d\n", sizeof(*a));   //什么含义？
printf("%d\n", sizeof(a[3])); //什么含义？


理解指针与数组的题目
int a[5][5] = { 0 };
for (int i = 0; i < 25; i++)
{
	*(&**a + i) = i;
}
for (int i = 0; i < 25; i++)
{
	printf("%d ", *(&**a + i));
}
puts("");

int(*p)[4];  //定义一个类型为int[4]的指针变量
p = (int(*)[4])a;  //强转只是为了让编译器不警告
printf("pa=%p, pb=%p\n", &a[4][2], &p[4][2]);  //请问结果分别是多少?
printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);//指针做差结果是元素的个数,可正可负

//先将指针模拟数组多维访问的方式降维成一维的计算方式: p[4][2] = *(*(p + 4) + 2);
//然后将数组物理结构图展开
//p所指向的类型是int[4],因此步长是4个int
//a本身是数组,不需要降维
//编译器会查看元素是否是地址,或者说,默认指针计算就是把元素值当作地址.所以不用当心指针解引用后是指针还是数据的影响.


数组传参过程,函数形参中括号[]内的常数可以省略,因为数组最终会降维成指针,指针使用[]就没有数组这样的约束了

所有的数组,都可以看成一维数组.所有的数组传参,最终都会降维成一维数组
1.二维数组降维
void func(int(*p)[6],int size) //一维数组,数组元素类型为int[6][7][8]
{ }

int main()
{
	int a[5][6] = { 0 };
	func(a,5);
	return 0;
}

2.高维数组降维
void func(int(*p)[6][7][8],int size)  //一维数组,数组元素类型为int[6][7][8]
{ }

int main()
{
	int a[5][6][7][8] = { 0 };
	func(a,5);
	return 0;
}

验证: 只有第一个中括号能省略,即明确要求降维成一维指针
void func(int p[][6][7][8],int size)  
{ }

int main()
{
	int a[5][6][7][8] = { 0 };
	func(a,5);
	return 0;
}
如果省略了指针第一个[]内的数值,则指针的类型就会不明确


//为什么要降维? 不降维就要拷贝整个数组,成本开销很大,降维成指针后只需要拷贝地址



函数的地址
void func()
{ }

int main()
{
	printf("%p\n", func); //常用
	printf("%p\n", &func);
	return 0;
}
C语言中函数名和&函数名完全等价,都代表函数的地址
函数在程序中不可写入,只需要关心它的起始位置在哪里

要保存函数的地址,就需要使用函数指针变量
函数指针可以通过圆括号()来调用指向的函数.例如p();





