## 预处理

[TOC]

<br>

### 宏定义

#### 数值宏常量

> #define 宏定义是个演技非常高超的替身演员，但也会经常耍大牌的，所以我们用它要慎之又慎。它可以出现在代码的任何地方，从本行宏定义开始，以后的代码就都认识这个宏了；也可以把任何东西定义成宏。因为编译器会在预编译的时候用真身替换替身，而在我们的代码里面却又用常常用替身来帮忙。看例子：
>
> #define PI 3.141592654
>
> 在此后的代码中尽可以使用 PI 来代替 3.141592654，而且你最好就这么做。不然的话，如果我要把PI的精度再提高一些，你是否愿意一个一个的去修改这串数呢？你能保证不漏不出错？而使用 PI 的话，我们却只需要修改一次。这种情况还不是最要命的，我们再看一个例子：
>
> #define ERROR_POWEROFF -1
>
> 如果你在代码里不用 ERROR_POWEROFF 这个宏而将-1硬编码进代码里，尤其在函数返回错误代码的时候（往往一个开发一个系统需要定义很多错误代码）。肯怕上帝都无法知道-1 表示的是什么意思吧。这个-1，我们一般称为“魔鬼数”，上帝遇到它也会发狂的。所以，我奉劝代码里一定不要出现“魔鬼数”。
>
> 关键字篇我们讨论了 const 这个关键字，我们知道const 修饰的数据是有类型的，而 define 宏定义的数据没有类型。为了安全，我建议以后在定义一些宏常数的时候用 const 代替，编译器会给 const 修饰的只读变量做类型校验，减少错误的可能。但一定要注意const修饰的不是常量而是readonly的变量，const 修饰的只读变量不能用来作为定义数组的维数，也不能放在 case 关键字后面。

#### 字符串宏常量

> #define ENG_PATH_4 "E:\\English\\listen_to_this\\listen_to_this_3"

#### 用define宏定义注释符号？

> 预处理: 头文件展开,去掉注释,宏替换,条件编译 (顺序是怎样的?)
>
> 编译: C语言翻译成汇编语言
>
> 汇编: 将汇编代码转化成可重定向目标文件(可被链接)
>
> 链接: 自身程序+库文件进行关联,形成可执行程序