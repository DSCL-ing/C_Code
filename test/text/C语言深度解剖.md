#pragma once



#### 1.程序的本质:二进制文件  
运行程序,即将程序中的数据加载到内存中运行  
为什么要加载到内存? 1.冯诺依曼体系 2.快  

### 变量
##### 1.变量:内存上的某个位置开辟的空间  
> 因为变量都是程序运行起来才开辟的

##### 2.变量的初始化:  
变量的空间被开辟后,就应当具有对应的数据,即必须要初始化.表示该变量与生俱来的属性就是该初始值

##### 3.为什么要有变量
计算机是为了解决人计算能力不足的问题而诞生的.即,计算机是为了计算的.  
而计算,就需要数据  
而要计算,任何时刻,不是所有的数据都要立马被计算,因此有的数据需要暂时被保存起来,等待后续处理. 所以需要变量

##### 4.局部变量与全局变量
- 局部变量:包含在代码块中的变量叫做局部变量.局部变量具有临时性.进入代码块,自动形成局部变量,退出代码块自动释放. 局部变量在栈区保存
- 全局变量:在所有函数外定义的变量,叫做全局变量.全局变量具有全局性.全局变量在全局已初始化数据区保存.
- 代码块:用花括号\{}括起来的区域,就叫做代码块.

##### 5.变量的大小由类型决定



### 1.1 关键字auto
默认情况下,编译器默认所有的局部变量都是auto的,auto一般只能用来修饰局部变量,不能修饰全局变量.ju'bu也叫自动变量.一般情况下都是省略auto关键字的.基本永不使用

### 1.2 关键字register
建议性关键字,建议编译器将该变量优化到寄存器上,具体情况由编译器决定  
(不建议大量使用,因为寄存器数量有限)
##### 什么样的变量可以采用register?
1. 局部的(全局会导致CPU寄存器被长时间占用)
2. 高频被读取的(提高访问效率)
3. 不会被写入的(写入就需要写回内存,后续还需要读取检测的话,register就没有意义了)  

寄存器变量是不能被取地址的,因为不在内存中,就没有内存地址  
register不会影响变量的生命周期,只有static会影响变量的生命周期


### 1.3.1 多文件:
具有一定规模的项目是需要文件与文件之间进行交互的.如果不能直接跨文件调用,则项目在这方面一定需要很大成本解决.因此C默认是支持跨文件的
1. #### extern  
    - 功能:声明,引入别的源文件的变量或函数
    - extern与头文件的渊源:
 最开始时,没有头文件,源文件之间的互相引用是通过extern进行的.当项目复杂后,引用需要写的声明越来越多,每个源文件引入别的源文件的变量或函数时都需要声明一次,维护变得麻烦.为了解决这种情况,头文件就出来了,只需声明一次就可以到处使用.  
现在基本上多文件项目都是头文件放声明,源文件放定义
    - 怎么声明变量和函数? 
        - 变量:  
            定义:`int a = 10;`  
            声明:`extern int a;` (不能带上初始值)
        - 函数:  
            定义:`void print(){ //... }`  
            声明:`extern void printf();` (不能带上函数体)
    

2. #### 头文件
- 头文件一般包含:
    * C头文件
    * 所有的变量的声明
    * 所有函数的声明
    * #define, 类型typedef, struct  
- 头文件中函数的声明可以不带上extern, 但是变量的声明必须带上extern, 因为头文件最终是要展开到源文件中去的,源文件内可以定义和声明,那头文件也可以,如果头文件中变量声明不带extern,则无法区分该变量是声明还是定义(二义性).


#### 1.3.2 static
static给项目维护给提供了安全保证,像封装一样,隐藏实现
功能:
1. static修饰全局变量,该变量只在本文件内被访问, 不能被外部其他文件直接访问
2. static修饰函数,该函数只能在本文件内被访问,不能被外部其他文件直接访问  
3. static局部变量变成静态变量,放在静态区,改变了局部变量的生命周期,使其生命周期变长。 
   - static修饰全局变量和函数,改变的是它们的作用域,生命周期不变.static修饰局部变量,改变的是局部变量的生命周期,作用域不变  
   - static修饰的局部变量会放在进程地址空间的 已初始化数据区,在进程的整个生命周期内都是有效的.

![进程地址空间](../img/进程地址空间.png)
### 进程地址空间
1. 代码区
程序执行代码存放在代码区，其值不能修改（若修改则会出现错误）。
字符串常量和define定义的常量也有可能存放在代码区。

2. 常量区
字符串、数字等常量存放在常量区。
const修饰的全局变量存放在常量区。
程序运行期间，常量区的内容不可以被修改。

3. 全局区（静态区）
全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。

4. 堆区(heap)
堆区由程序员分配内存和释放。
堆区按内存地址由低地址到高地址增长，用malloc, calloc, realloc等分配内存的函数分配得到的就是在堆上。

5. 栈区(stack)
存放内容
临时创建的局部变量和const定义的局部变量存放在栈区。
函数调用和返回时，其入口参数和返回值存放在栈区。
>    - 为什么局部变量具有临时性? 因为局部变量是存在栈中的.栈具有后进先出(压栈)的特性,除了作用域后需要将该范围的所有变量弹出.

### 1.4类型
- C语言为何有类型? 让我们能够对内存进行合理化划分,按需索取,存在类型的目的就是让我们能合理使用内存空间  
- 类型为什么有这么多种? 实际应用场景很多种,应用场景不同,解决对应的应用场景的计算方式不同,需要空间的大小也是不同的.多种类型目的是让我们能以最下成本解决多样化的场景问题.
> 例如: 登记成绩,成绩只要0-100分,那使用一1个字节int8_t/char就足够. 如果带浮点,则需要浮点型.  


### 1.5 关键字sizeof
sizeof是函数还是关键字?
1. 证明1:
```C
int a = 10;
printf("%d\n",sizeof(a));    //正确用法
printf("%d\n",sizeof(int));  //正确用法
printf("%d\n",sizeof a );    //正确用法,证明sizeof不是函数
printf("%d\n",sizeof int );  //不存在
```
2. 证明2:函数调用栈帧中sizeof不会压栈


### 1.6关键字unsigned和signed
##### 数据在计算机中的存储
- 任何数据在计算机中都必须被转化成二进制,因为计算机只认识二进制.而计算机还要区分数据是正数还是负数,则二进制又分为`符号位 + 数据位`.
- 计算机内存储的整型必须是补码
- 无符号数和正数的原反补码相等,直接存入计算机中.负数需要将原码转化成补码再存储
- 类型决定了如何解释空间内部保存的二进制序列
- 浮点数默认是double类型,如果想要float需要在数后加上f,如`float f = 1.1f`;

##### 原码 反码 补码的转化与硬件关系  
```
例: int b = -20; //20 = 16+4 = 2^4^ (10000)~2~+ 2^2^(100)~2~  
//有符号数且负数 原码转成补码:
1000 0000 0000 0000 0000 0000 0001 0100  原码
1111 1111 1111 1111 1111 1111 1111 1011  反码 = 原码取反
1111 1111 1111 1111 1111 1111 1111 1100  补码 = 反码+1

//补码转原码
方法一: 原理
1111 1111 1111 1111 1111 1111 1111 1100  补码 
1111 1111 1111 1111 1111 1111 1111 1011  反码 = 补码-1
1000 0000 0000 0000 0000 0000 0001 0100  原码 = 反码取反

方法二: 计算机硬件使用的方式, 可以使用一条硬件电路,完成原码补码互转
1111 1111 1111 1111 1111 1111 1111 1100  补码 
1000 0000 0000 0000 0000 0000 0000 0011  补码取反
1000 0000 0000 0000 0000 0000 0000 0100  +1
```

##### 整型存储的本质
定义`unsigned int b = -10;` 能否正确运行? 答案是可以的.
定义的过程是开辟空间,而空间只能存储二进制,并不关心数据的内容
数据要存储到空间里,必须先转成二进制补码.而在写入空间时,数据已经转化成补码

##### 变量存取的过程
- 存: 字面数据必须先转成补码,再放入空间中.符号位只看数据本身是否携带+-号,和变量是否有符号无关.
- 取: 取数据一定要先看变量本身类型,然后才决定要不要看最高符号位.如果不需要,则直接将二进制转成十进制.如果需要,则需要转成原码,然后才能识别(还需要考虑最高符号位在哪里,考虑大小端)

##### 类型目前的作用
1. 存数据前决定开辟多大的空间
2. 读数据时如何解释二进制数据

特定数据类型能表示多少个数据,取决于自己所有比特位排列组合的个数

##### 十进制与二进制快速转换
```
(前置知识:需要熟记2^0到2^10的十进制结果)
    1 -> 2^0
   10 -> 2^1
  100 -> 2^2
 1000 -> 2^3  //1后面跟3个比特位就是2^3
 规律: 1后n个0就是2^n,即n等于几1后面就跟几个0 --- 十进制转二进制
        反过来就是1后面跟几个0,就是2的几次方 --- 二进制转十进制
 因此:2^9 -> 10 0000 0000 // n

例: 67 = 64+2+1 -> 2^6+2^1+2^0 -> 1000000 + 10 + 1
       = 0000 0000 .... 0100 0011
同理,二进制转十进制逆过程即可
```

##### 大小端字节序

现象: vs的内存窗口中,地址从上到下依次增大,从左到右也依次增大

1. 大端:按照字节为单位,低权值位数据存储在高地址处,就叫做大端
2. 小段:按照字节为单位,低权值位数据存储在低地址处,就叫做小端(小小小)

(基本上以小端为主,大端比较少(网络))

大小端存储方案,本质是数据和空间按照字节为单位的一种映射关系

(考虑大小端问题是1字节以上的类型.short,int,double...)

##### 判断当前机器的字节序
- 方法1: 对`int a = 1` 取首地址,然后`(char*)&a`,得到的值是1则为小端,否则为大端
- 方法2: 打开内存窗口查看地址与数据的字节序

##### "负零"(-128)的理解
```
(负零的概念并不存在,只是碰巧相像)
-128实际存入到计算机中是以 1 1000 0000 表示的(计组运算器).但空间只有8位,发生截断,因此得到1000 0000.
而[1111 1111,1000 0001]~[0000 0000,0111 1111]  
即[-127,-1]~[0,127] 自然数都已经被使用 .  
计算机不能浪费每一个空间(最小的成本尽可能解决大量的计算),自然1000 0000也需要有相应的意义. 因此赋予数值为-128.

因为截断后也不可能恢复,所以这是一种半计算半规定的做法.
```
![数据的范围](../img/数据的范围.png)  

##### 截断
截断是空间不足以存放数据时,将高位截断.  
> 截断的是高位还是低位? 因为赋值永远都是从低地址赋起(从低到高依次赋值),因此空间不足时高位直接丢弃.

1 0000 0001 0100
1 1111 1110 1100
0 0000 0000 1010
1 1111 1111 0110 
1 0000 0000 1010

##### 建议在无符号类型的数值后带上u,
默认的数值是有符号的,在数值后加u更加严格,`unsigned int a = 10u;`

### 1.7 if-else组合
- 表达式: 变量与操作符的组合称为表达式
- 语句: 以分号结尾的表达式称为语句
- if(0){ //... }注释法,在看到if(0)时,有可能这是一个注释,不推荐这种做法,但是需要认识.

#### if的执行顺序
1. 先执行完毕if括号()中的表达式or某种函数,得到表达式的真假结果
2. 判定功能:根据表达式结果进行条件判定
3. 分支功能:根据判定结果进行分支  
    > (if有判定和分支两个功能,而switch只有判定而没有分支功能,因此必须使用break)

#### 操作符的执行顺序测试方法
`printf("1   ") && printf("2   ");`  
`printf("1   ") || printf("2   ");`

#### C语言的布尔类型
- C89/C90没有bool类型
- C99 引入了关键字为_Bool的类型,在新增的头文件stdbool.h中.为了保证C/C++的兼容性,被重新用宏写成了bool.
- 微软对C语言bool类型也有一套标准,BOOL,FALSE,TRUE. 不推荐使用微软这套标准,不具备可移植性

#### 浮点数与"零值"比较

- ##### 精度损失:浮点值与实际值不等,可能偏大可能偏小,都属于精度损失  
    1. **验证浮点数是否存在精度损失**  
    ![精度损失1](../img/精度损失1.png)  
    2. **验证浮点数的差值是否存在精度损失**  
    ![精度损失2](../img/精度损失2.png)
    3. **浮点数直接比较验证**  
    ![精度损失3](../img/精度损失3.png)  
    **结论: 浮点数在进行比较时,绝对不能使用双等号`==`来进行比较.  浮点数本身有精度损失,进而导致结果可能有细微的差别.**  

- ##### 如何进行浮点数比较
```C
1. x - y == 0的条件是 |x - y| < 精度.
即 x - y > -精度 && x - y < 精度

2.还可以使用fabs函数,C90,<math.h>, double fabs(double x); 返回x的绝对值.
即 fabs(x-y) < 精度
```
```
//--------------------------------------------------------------
//方法1,自定义精度
#include<stdio.h>
#include<math.h>

#define EPSILON 0.0000000000000001 //自定义精度,验证的最小精度,16位
int main()
{
    double x = 1.0;
    double y = 0.1;

    //验证x - 0.9 是否等于 0.1
    if(fabs((x-0.9)- y) < EPSILON ) printf("aaaa\n");
    else printf("bbbb\n");

    puts("hello world!");
    return 0;
}
```
```
//方法2:使用C语言提供的精度
#include<stdio.h>
#include<math.h>
#include<float.h>

int main()
{
    double x = 1.0;
    double y = 0.1;

    //验证x - 0.9 是否等于 0.1
    //<float.h> 内置最小精度值 DBL_EPSILON 和 FLT_EPSILON ,1.0+DBL_EPSILON != 1.0 ,1.0加上一个很小很小的值不等于1.0,EPSILON就是这个很小的值,数学概念,略
    if(fabs((x-0.9)- y) < DBL_EPSILON ) printf("aaaa\n");
    else printf("bbbb\n");
    
    return 0;
}
```
![浮点比较方法1](../img/浮点比较方法1.png)

