#pragma once



#### 1.程序的本质:二进制文件  
运行程序,即将程序中的数据加载到内存中运行  
为什么要加载到内存? 1.冯诺依曼体系 2.快  

### 变量
##### 1.变量:内存上的某个位置开辟的空间  
> 因为变量都是程序运行起来才开辟的

##### 2.变量的初始化:  
变量的空间被开辟后,就应当具有对应的数据,即必须要初始化.表示该变量与生俱来的属性就是该初始值

##### 3.为什么要有变量
计算机是为了解决人计算能力不足的问题而诞生的.即,计算机是为了计算的.  
而计算,就需要数据  
而要计算,任何时刻,不是所有的数据都要立马被计算,因此有的数据需要暂时被保存起来,等待后续处理. 所以需要变量

##### 4.局部变量与全局变量
- 局部变量:包含在代码块中的变量叫做局部变量.局部变量具有临时性.进入代码块,自动形成局部变量,退出代码块自动释放. 局部变量在栈区保存
- 全局变量:在所有函数外定义的变量,叫做全局变量.全局变量具有全局性.全局变量在全局已初始化数据区保存.
- 代码块:用花括号\{}括起来的区域,就叫做代码块.

##### 5.变量的大小由类型决定



### 1.1 关键字auto
默认情况下,编译器默认所有的局部变量都是auto的,auto一般只能用来修饰局部变量,不能修饰全局变量.ju'bu也叫自动变量.一般情况下都是省略auto关键字的.基本永不使用

### 1.2 关键字register
建议性关键字,建议编译器将该变量优化到寄存器上,具体情况由编译器决定  
(不建议大量使用,因为寄存器数量有限)
##### 什么样的变量可以采用register?
1. 局部的(全局会导致CPU寄存器被长时间占用)
2. 高频被读取的(提高访问效率)
3. 不会被写入的(写入就需要写回内存,后续还需要读取检测的话,register就没有意义了)  

寄存器变量是不能被取地址的,因为不在内存中,就没有内存地址  
register不会影响变量的生命周期,只有static会影响变量的生命周期


### 1.3.1 多文件:
具有一定规模的项目是需要文件与文件之间进行交互的.如果不能直接跨文件调用,则项目在这方面一定需要很大成本解决.因此C默认是支持跨文件的
1. #### extern  
    - 功能:声明,引入别的源文件的变量或函数
    - extern与头文件的渊源:
 最开始时,没有头文件,源文件之间的互相引用是通过extern进行的.当项目复杂后,引用需要写的声明越来越多,每个源文件引入别的源文件的变量或函数时都需要声明一次,维护变得麻烦.为了解决这种情况,头文件就出来了,只需声明一次就可以到处使用.  
现在基本上多文件项目都是头文件放声明,源文件放定义
    - 怎么声明变量和函数? 
        - 变量:  
            定义:`int a = 10;`  
            声明:`extern int a;` (不能带上初始值)
        - 函数:  
            定义:`void print(){ //... }`  
            声明:`extern void printf();` (不能带上函数体)
    

2. #### 头文件
- 头文件一般包含:
    * C头文件
    * 所有的变量的声明
    * 所有函数的声明
    * #define, 类型typedef, struct  
- 头文件中函数的声明可以不带上extern, 但是变量的声明必须带上extern, 因为头文件最终是要展开到源文件中去的,源文件内可以定义和声明,那头文件也可以,如果头文件中变量声明不带extern,则无法区分该变量是声明还是定义(二义性).


#### 1.3.2 static
static给项目维护给提供了安全保证,像封装一样,隐藏实现
功能:
1. static修饰全局变量,该变量只在本文件内被访问, 不能被外部其他文件直接访问
2. static修饰函数,该函数只能在本文件内被访问,不能被外部其他文件直接访问  
3. static局部变量变成静态变量,放在静态区,改变了局部变量的生命周期,使其生命周期变长。 
   - static修饰全局变量和函数,改变的是它们的作用域,生命周期不变.static修饰局部变量,改变的是局部变量的生命周期,作用域不变  
   - static修饰的局部变量会放在进程地址空间的 已初始化数据区,在进程的整个生命周期内都是有效的.

![进程地址空间](../img/进程地址空间.png)
### 进程地址空间
1. 代码区
程序执行代码存放在代码区，其值不能修改（若修改则会出现错误）。
字符串常量和define定义的常量也有可能存放在代码区。

2. 常量区
字符串、数字等常量存放在常量区。
const修饰的全局变量存放在常量区。
程序运行期间，常量区的内容不可以被修改。

3. 全局区（静态区）
全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。

4. 堆区(heap)
堆区由程序员分配内存和释放。
堆区按内存地址由低地址到高地址增长，用malloc, calloc, realloc等分配内存的函数分配得到的就是在堆上。

5. 栈区(stack)
存放内容
临时创建的局部变量和const定义的局部变量存放在栈区。
函数调用和返回时，其入口参数和返回值存放在栈区。
>    - 为什么局部变量具有临时性? 因为局部变量是存在栈中的.栈具有后进先出(压栈)的特性,除了作用域后需要将该范围的所有变量弹出.

### 1.4类型
- C语言为何有类型? 让我们能够对内存进行合理化划分,按需索取,存在类型的目的就是让我们能合理使用内存空间  
- 类型为什么有这么多种? 实际应用场景很多种,应用场景不同,解决对应的应用场景的计算方式不同,需要空间的大小也是不同的.多种类型目的是让我们能以最下成本解决多样化的场景问题.
> 例如: 登记成绩,成绩只要0-100分,那使用一1个字节int8_t/char就足够. 如果带浮点,则需要浮点型.  


### 1.5 关键字sizeof
sizeof是函数还是关键字?
1. 证明1:
```C
int a = 10;
printf("%d\n",sizeof(a));    //正确用法
printf("%d\n",sizeof(int));  //正确用法
printf("%d\n",sizeof a );    //正确用法,证明sizeof不是函数
printf("%d\n",sizeof int );  //不存在
```
2. 证明2:函数调用栈帧中sizeof不会压栈


### 1.6关键字unsigned和signed
##### 数据在计算机中的存储
- 任何数据在计算机中都必须被转化成二进制,因为计算机只认识二进制.而计算机还要区分数据是正数还是负数,则二进制又分为`符号位 + 数据位`.
- 计算机内存储的整型必须是补码
- 无符号数和正数的原反补码相等,直接存入计算机中.负数需要将原码转化成补码再存储
- 类型决定了如何解释空间内部保存的二进制序列
- 浮点数默认是double类型,如果想要float需要在数后加上f,如`float f = 1.1f`;

##### 原码 反码 补码的转化与硬件关系  
```
例: int b = -20; //20 = 16+4 = 2^4^ (10000)~2~+ 2^2^(100)~2~  
//有符号数且负数 原码转成补码:
1000 0000 0000 0000 0000 0000 0001 0100  原码
1111 1111 1111 1111 1111 1111 1111 1011  反码 = 原码取反
1111 1111 1111 1111 1111 1111 1111 1100  补码 = 反码+1

//补码转原码
方法一: 原理
1111 1111 1111 1111 1111 1111 1111 1100  补码 
1111 1111 1111 1111 1111 1111 1111 1011  反码 = 补码-1
1000 0000 0000 0000 0000 0000 0001 0100  原码 = 反码取反

方法二: 计算机硬件使用的方式, 可以使用一条硬件电路,完成原码补码互转
1111 1111 1111 1111 1111 1111 1111 1100  补码 
1000 0000 0000 0000 0000 0000 0000 0011  补码取反
1000 0000 0000 0000 0000 0000 0000 0100  +1
```

##### 整型存储的本质
定义`unsigned int b = -10;` 能否正确运行? 答案是可以的.
定义的过程是开辟空间,而空间只能存储二进制,并不关心数据的内容
数据要存储到空间里,必须先转成二进制补码.而在写入空间时,数据已经转化成补码

##### 变量存取的过程
- 存: 字面数据必须先转成补码,再放入空间中.符号位只看数据本身是否携带+-号,和变量是否有符号无关.
- 取: 取数据一定要先看变量本身类型,然后才决定要不要看最高符号位.如果不需要,则直接将二进制转成十进制.如果需要,则需要转成原码,然后才能识别(还需要考虑最高符号位在哪里,考虑大小端)

##### 类型目前的作用
1. 存数据前决定开辟多大的空间
2. 读数据时如何解释二进制数据

特定数据类型能表示多少个数据,取决于自己所有比特位排列组合的个数

##### 十进制与二进制快速转换
```
(前置知识:需要熟记2^0到2^10的十进制结果)
    1 -> 2^0
   10 -> 2^1
  100 -> 2^2
 1000 -> 2^3  //1后面跟3个比特位就是2^3
 规律: 1后n个0就是2^n,即n等于几1后面就跟几个0 --- 十进制转二进制
        反过来就是1后面跟几个0,就是2的几次方 --- 二进制转十进制
 因此:2^9 -> 10 0000 0000 // n

例: 67 = 64+2+1 -> 2^6+2^1+2^0 -> 1000000 + 10 + 1
       = 0000 0000 .... 0100 0011
同理,二进制转十进制逆过程即可
```

##### 大小端字节序

现象: vs的内存窗口中,地址从上到下依次增大,从左到右也依次增大

1. 大端:按照字节为单位,低权值位数据存储在高地址处,就叫做大端
2. 小段:按照字节为单位,低权值位数据存储在低地址处,就叫做小端(小小小)

(基本上以小端为主,大端比较少(网络))

大小端存储方案,本质是数据和空间按照字节为单位的一种映射关系

(考虑大小端问题是1字节以上的类型.short,int,double...)

##### 判断当前机器的字节序
- 方法1: 对`int a = 1` 取首地址,然后`(char*)&a`,得到的值是1则为小端,否则为大端
- 方法2: 打开内存窗口查看地址与数据的字节序

##### "负零"(-128)的理解
```
(负零的概念并不存在,只是碰巧相像)
-128实际存入到计算机中是以 1 1000 0000 表示的(计组运算器).但空间只有8位,发生截断,因此得到1000 0000.
而[1111 1111,1000 0001]~[0000 0000,0111 1111]  
即[-127,-1]~[0,127] 自然数都已经被使用 .  
计算机不能浪费每一个空间(最小的成本尽可能解决大量的计算),自然1000 0000也需要有相应的意义. 因此赋予数值为-128.

因为截断后也不可能恢复,所以这是一种半计算半规定的做法.
```
![数据的范围](../img/数据的范围.png)  

##### 截断
截断是空间不足以存放数据时,将高位截断.  
> 截断的是高位还是低位? 因为赋值永远都是从低地址赋起(从低到高依次赋值),因此空间不足时高位直接丢弃.

1 0000 0001 0100
1 1111 1110 1100
0 0000 0000 1010
1 1111 1111 0110 
1 0000 0000 1010

##### 建议在无符号类型的数值后带上u,
默认的数值是有符号的,在数值后加u更加严格,`unsigned int a = 10u;`

### 1.7 if-else组合
- 表达式: 变量与操作符的组合称为表达式
- 语句: 以分号结尾的表达式称为语句
- if(0){ //... }注释法,在看到if(0)时,有可能这是一个注释,不推荐这种做法,但是需要认识.

#### if的执行顺序
1. 计算功能:先执行完毕if括号()中的表达式or某种函数,得到表达式的真假结果
2. 判定功能:根据表达式结果进行条件判定
3. 分支功能:根据判定结果进行分支  
    > (if有判定和分支两个功能,而switch只有判定而没有分支功能,因此必须使用break)

#### 操作符的执行顺序测试方法
`printf("1   ") && printf("2   ");`  
`printf("1   ") || printf("2   ");`

#### C语言的布尔类型
- C89/C90没有bool类型
- C99 引入了关键字为_Bool的类型,在新增的头文件stdbool.h中.为了保证C/C++的兼容性,被重新用宏写成了bool.
- 微软对C语言bool类型也有一套标准,BOOL,FALSE,TRUE. 不推荐使用微软这套标准,不具备可移植性

#### 浮点数与"零值"比较

- ##### 精度损失:浮点值与实际值不等,可能偏大可能偏小,都属于精度损失  
    1. **验证浮点数是否存在精度损失**  
    ![精度损失1](../img/精度损失1.png)  
    2. **验证浮点数的差值是否存在精度损失**  
    ![精度损失2](../img/精度损失2.png)
    3. **浮点数直接比较验证**  
    ![精度损失3](../img/精度损失3.png)  
    **结论: 浮点数在进行比较时,绝对不能使用双等号`==`来进行比较.  浮点数本身有精度损失,进而导致结果可能有细微的差别.**  

- ##### 如何进行浮点数比较
```C
1. x - y == 0的条件是 |x - y| < 精度.
即 x - y > -精度 && x - y < 精度

2.还可以使用fabs函数,C90,<math.h>, double fabs(double x); 返回x的绝对值.
即 fabs(x-y) < 精度
```
```
//--------------------------------------------------------------
//方法1,自定义精度
#include<stdio.h>
#include<math.h>

#define EPSILON 0.0000000000000001 //自定义精度
int main()
{
    double x = 1.0;
    double y = 0.1;

    //验证x - 0.9 是否等于 0.1
    if(fabs((x-0.9)- y) < EPSILON ) printf("aaaa\n");
    else printf("bbbb\n");

    puts("hello world!");
    return 0;
}
```
```
//方法2:使用C语言提供的精度
#include<stdio.h>
#include<math.h>
#include<float.h>

int main()
{
    double x = 1.0;
    double y = 0.1;

    //验证x - 0.9 是否等于 0.1
    //<float.h> 内置最小精度值 DBL_EPSILON 和 FLT_EPSILON ,1.0+DBL_EPSILON != 1.0 ,EPSILON是改变1.0的最小的值,数学概念,略
    if(fabs((x-0.9)- y) < DBL_EPSILON ) printf("aaaa\n");
    else printf("bbbb\n");
    
    return 0;
}
```
![浮点比较方法1](../img/浮点比较方法1.png)

- 浮点数与"零值"比较,只需要判定它是否小于EPSILON即可
```
int main()
{
    double x = 0.0;
    // double x  = 0.00000000000000000000000000001; //很小也可以认为等于0
    if(fabs(x) < DBL_EPSILON ) printf("等于0\n");
    else printf("不等于0\n");
    
    return 0;
}
```

#### 补充:如何理解强制类型转化
**强制类型转化:不改变数据本身,只改变数据的类型**
- "123456" -> int:123456
```
字符串"123456"如何转化成整型值123456,能强转吗? 答案是不能,只能通过算法进行转化

因为"123456"的空间至少占了7个,而整型int只占4个字节.
```
- ##### 不同类型的0
```
printf("%d\n",0);
printf("%d\n",'\0');
printf("%d\n",NULL); //(void*)0
```
![不同类型的0](../img/不同类型的0.png)

### 1.8switch case组合
- **基本语法结构**  
```
//switch只能对整数进行判定
switch(整型变量/常量/整型表达式){
    case var1:
        break;
    case var2:
        break;
    case var3:
        break;
    default:
        break;
}
推荐使用switch的场景:只能用于整数判定且分支很多的情况下
```

- switch case 的功能
switch本身没有判断和分支能力,switch是拿着结果去找case进行匹配,  
case具有判定能力,但没有分支能力,case是通过break完成分支功能  
break具有分支功能,相当于if的分支能力.  
default相当else,处理异常情况

#### (补充) 屏蔽警告的方法
```
error C4996: 'scanf': This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
方法1:
#pragma warning(disable:4996)
方法2:
#define _CRT_SECURE_NO_WARNINGS //该宏定义必须写在文件的首行(头文件的前面)才有效
(如果宏没有宏值,则只能用在#ifdef等条件编译语句中,即只用于标识)
```

- ##### 在case中执行多条语句,建议case后都带上花括号.
  在case中定义变量,直接写会警告,需要带上花括号,但不建议在case中定义变量,如果非要这么做,可以封装成函数来替代.并且
![case](../img/case警告.png)  

- ##### 多个case执行同样语句
```C
int main()
{
    int n = 0 ;
    scanf("%d",&n);
    switch (n)
    {
        case 1: case 2: case 3: case 4: case 5:
            puts("周内");
            break;
        case 6:
            puts("周六");
            break;
        case 7:
            puts("周日");
            break;
        default:
            break;
    }
    return 0;
}
```

- default可以在switch中的任意位置,一般习惯放在最后的case后
- switch中尽量不要单独出现return.一般习惯用break,突然return容易搞混
- switch中不要使用bool值,不好维护
- case的值必须是数字常量,不能是`const int a = 1;`这种
- 按执行频率排列case语句,频率越高越靠前,能减少匹配次数

### 1.9 do、while、for
#### 循环的基本结构  
- 一般的循环都必须要有3种功能：  
    1. 循环条件初始化
    2. 循环条件判定
    3. 循环条件更新

(死循环除外)
```C
int main()
{
    int count = 10; //1.循环条件初始化
    while (count > 10) //2.循环条件判定
    {
        printf("%d\n", count); //3.业务逻辑
        count--; //4.循环条件更新
    }
    return 0;
}
```

- for循环  
```
使用样例:
for(int i = 0; i<10; i++)
{
    //业务逻辑
}
```
for的结构更加紧凑,更清晰
```
for(1.循环条件初始化； 2.循环条件判定； 4.循环条件更新){
    //3.业务逻辑
}
```


- do-while
```
//1.循环条件初始化
do{
  //2.业务逻辑
  //3.循环条件更新
}while(4.循环条件判定);
```
do while结构需要在while()后加上分号，容易忘记

#### continue跳转的位置
- while循环continue后会跳转到循环条件判定的位置,之后执行循环判定
- for循环会跳转到循环条件更新的位置,之后进行循环条件更新!!!

#### 循环设计的思想推荐
1.尽可能减少循环来回多次的跳转的次数 --- 涉及缓存,局部性原理,CPU命中概率.尽可能让代码执行的更加平滑
2.在多重循环中,如果有可能,应当将最长的循环放在最内层,最短的循环放在最外层,以减少CPU跨且循环层的次数.

#### 推荐使用for的前闭后开写法
```
推荐1:for语句循环的次数的计算方式
1.for(int i = 0; i<=9; i++){} //cnt = 9-0+1 = 10次
2.for(int i = 0; i<10; i++){} //cnt = 10-0 = 10次
3.for(int i = 6; i<=9; i++){} //cnt = 9-6+1 = 4次
4.for(int i = 6; i<10; i++){} //cnt = 10-6 = 4次
从计算角度,前闭后开写法能更加直观,快速

推荐2:下标映射时,思维清晰,不容易混乱
```

### 字符设备

##### (补充) char有有符号和无符号两种类型,字符是无符号类型.

#### (补充) getchar的返回值为什么是int
如果getchar返回值是char,因为char只能表示0-255个字符，刚好包含所有ascii码,如果getchar失败，则没有多余的位置返回错误信息.因此getchar返回值设计成int,int既能转化成字符,还有多余的数值当作错误码来使用.

##### 键盘输入的内容,以及往显示器中打印的内容,都是字符 --> 键盘/显示器称为字符设备
验证:printf scanf的返回值是输出和输入的字符数.


### 1.10 goto关键字
##### goto的用法
- 向下跳转
```
int main()
{
    puts("hello world 1!");
    goto end;
    puts("hello world 2!");
end:
    puts("hello world 3!");
    return 0;
}
```
-向上跳转
```
//用goto实现的循环
int main()
{
    int i = 0;
start:
    printf("[%d] goto running ...\n",i);
    i++;
    if(i<10) goto start;
    return 0;
}
```
- goto只能在本函数内使用,不能跨函数
- goto很灵活,容易出现问题,因此不受欢迎.但很多项目中goto用得也不少,在有能力的情况下可以使用

### 1.11 void
- void不能定义变量,因为void的类型大小是不确定的,编译器强制不允许定义变量.
- sizeof(void)的大小,在windows中为0,在linux中为1. 说明void的大小是不明确的,本身就被编译器解释成空类型.
- void作为空类型,理论上是不能开辟空间的,即使开辟了空间,也仅仅作为一个占位符看待(void的作用,告诉编译器他是空类型).  
    所以,既然无法开辟空间,那么也就无法作为正常变量使用,既然无法使用,编译器干脆就不让它定义变量.
- void不仅不能定义变量,而且还不能用于解释数据,如强转成void在赋值给int是不允许的:`int a = (void)10`; 以及接受返回值类型为void的函数的返回值也是不允许的;
- (补充)C语言函数可以不带返回值,默认的返回值类型是int.  --- 尽量写上返回值类型,不写返回值类型很容易被误解成返回值类型为void. 而且可读性还低.

- void作为函数参数的作用
```
void test1()    
{    
  puts("test1");    
}    
    
void test2(void)                                                                                                    
  puts("test2");    
}    
    
int main()    
{    
  test1(1,2,3,4); //正常运行   
  test2(1,2,3,4); //linux gcc报错:too many arguments to function 
                  //windows中是warning C4087: “test2”: 用“void”参数列表声明
  return 0;    
}    

```
说明:void作参数时,明确告知编译器不需要传参 .而参数列表为空时则不限制 -- 自解释  
- void\*  
`void *p = NULL;` 是可以编译通过的.因为void\*是指针,指针在任何平台的大小都是明确的.32位占4字节,64位占8字节. 大小明确,所以能够定义变量
- void\*可以被任何类型的指针变量接受,void\*也可以接受任意的指针类型(常用)  
如在库,系统接口的设计上,设计成通用接口.
![void](../img/void.png)

- void\*类型的指针在vs中不能加减,gcc中可以加减  
解释:指针加减的大小是sizeof(类型),以满足连续的数据存放需要(如数组).  
而sizeof(void)在vs中是0,加减没有意义,所以干脆强制不能自增自减等操作.而gcc中sizeof(void)为1,即一个占位符的大小,因此还是可以加减.  

- GNU C(扩展C)和ANSI C(标准C)

- void\*类型不能解引用  
解释:也是sizeof(void)和void不能定义变量的问题


### 1.12return关键字
- #### return语句不可返回指向"栈内存"的指针,因为该内存在函数结束时会自动销毁.
- #### (补充) 栈帧
    - 栈帧:函数在栈区中开辟的空间,就叫栈帧
    - 栈帧的大小,编译器有能力在开辟前可以通过sizeof根据函数内的变量类型和数量预估出来(1.关键字本身就是编译器用的 2.不同的编译器计算方式不一样)
    - 调用函数,创建栈帧. 函数返回,释放栈帧(释放就是允许被覆盖.空间使用权不再属于这个函数,别的函数也可以使用)
    - 为什么临时变量具有临时性,就是因为函数返回后要释放栈帧,栈帧被释放,栈帧内的变量所需的空间自然也被释放.因此临时变量具有临时性
    - 栈帧无效并不是清空栈帧的内容,栈帧内容不会改变,但是使用权已归还.等下个函数调用时,新的栈帧就会覆盖掉旧的栈帧.
    - 越早创建的栈帧地址越高,因为栈是向下(低地址)增长的.
    - main函数也是函数,也有自己的栈帧.(调用main函数的函数是\_start函数或__tmainCRTSstartup()函数...)
    - 递归就是不断向下形成栈帧的过程.因为栈大小是有限制的,递归过多有可能会发生栈溢出问题.  
<br>


- #### 函数的返回值的返回方式
  - 函数的返回值通过保存在寄存器的方式,返回给函数调用方.  
  - 如果有对应的接受变量,则会形成对应的接受汇编语句.就算没有变量接受返回值也会将返回值放到寄存器中,只是没有生成接受语句.
```
int getDate()
{
    int x = 0x11223344;
    puts("getDate");
    return x;
}

int main()
{
    int y = getDate();
    return 0;
}
```
![return](../img/return.png)

- #### 返回值具有const属性...

### 1.13const
- const 直接修饰变量时,该变量不可被直接修改(可以间接修改)
![const](../img/const.png)
- const 放在类型前和类型后是一样的.
- 既然const可以被间接修改,那const有什么意义?
    1. const是给编译器看的,const能够让编译器在编译代码时对用const的变量进行语法检查,凡是对const修饰的变量有直接修改行为的,编译器会直接报错. 
    2. const是给其他程序员看的,其他程序员发现有变量被const修饰时,就知道这个变量不能直接被修改,即这份代码有了一定的自身描述性(自描述)
- 真正的不可修改
![](../img/const真正的不可修改.png)  
(字符串常量不可修改是操作系统级别的保护,真正的不可修改. 原理相关:OS页表和权限)  
- const是在编译期间限制不可修改(所有的报错都是在编译期间).
- 标准C下const修饰的变量不可以用于定义数组(必须是宏或字面值).有的扩展C可以.
- 只读数组 ` const int a[] = { 1,2,3,4,5 };`, 数组的每个元素都不可被修改

##### 带const的类型  
定义整型指针变量p,用于初始化q : `int *q = p;`   
如果p的定义方式是`const int *p`,则p的类型是`const int*`,因此初始化时q会告警.对p强转后再赋值,不会告警`int*q = (int*)p;`  
如果p的定义方式是`int const *p`,则p的类型是`int*`,因此初始化q时不会告警.  

#### 带const的类型可以直接传给不带const的类型:权限可以缩小,但不可以放大

### 指针
- 取地址:在C中,任何变量&都是最低地址开始! 取得是一个变量所占空间的最低地址
