#pragma once



#### 1.程序的本质:二进制文件  
运行程序,即将程序中的数据加载到内存中运行  
为什么要加载到内存? 1.冯诺依曼体系 2.快  

### 变量
#### 1.变量:内存上的某个位置开辟的空间  
> 因为变量都是程序运行起来才开辟的

#### 2.变量的初始化:  
变量的空间被开辟后,就应当具有对应的数据,即必须要初始化.表示该变量与生俱来的属性就是该初始值

#### 3.为什么要有变量
计算机是为了解决人计算能力不足的问题而诞生的.即,计算机是为了计算的.  
而计算,就需要数据  
而要计算,任何时刻,不是所有的数据都要立马被计算,因此有的数据需要暂时被保存起来,等待后续处理. 所以需要变量

#### 4.局部变量与全局变量
- 局部变量:包含在代码块中的变量叫做局部变量.局部变量具有临时性.进入代码块,自动形成局部变量,退出代码块自动释放. 局部变量在栈区保存
- 全局变量:在所有函数外定义的变量,叫做全局变量.全局变量具有全局性.全局变量在全局已初始化数据区保存.
- 代码块:用花括号\{}括起来的区域,就叫做代码块.

### 关键字
#### 1.1 auto
默认情况下,编译器默认所有的局部变量都是auto的,auto一般只能用来修饰局部变量,不能修饰全局变量.ju'bu也叫自动变量.一般情况下都是省略auto关键字的.基本永不使用

#### 1.2 register
建议性关键字,建议编译器将该变量优化到寄存器上,具体情况由编译器决定  
(不建议大量使用,因为寄存器数量有限)
##### 什么样的变量可以采用register?
1. 局部的(全局会导致CPU寄存器被长时间占用)
2. 高频被读取的(提高访问效率)
3. 不会被写入的(写入就需要写回内存,后续还需要读取检测的话,register就没有意义了)  

寄存器变量是不能被取地址的,因为不在内存中,就没有内存地址  
register不会影响变量的生命周期,只有static会影响变量的生命周期


#### 1.3.1 多文件:
1. ##### extern  
    - 功能:声明,引入别的源文件的变量或函数
    - extern与头文件的渊源:
 最开始时,没有头文件,源文件之间的互相引用是通过extern进行的.当项目复杂后,引用需要写的声明越来越多,每个源文件引入别的源文件的变量或函数时都需要声明一次,维护变得麻烦.为了解决这种情况,头文件就出来了,只需声明一次就可以到处使用.  
现在基本上多文件项目都是头文件放声明,源文件放定义
    - 怎么声明变量和函数? 
        - 变量:  
            定义:`int a = 10;`  
            声明:`extern int a;` (不能带上初始值)
        - 函数:  
            定义:`void print(){ //... }`  
            声明:`extern void printf();` (不能带上函数体)
    

2. ##### 头文件
- 头文件一般包含:
    * C头文件
    * 所有的变量的声明
    * 所有函数的声明
    * #define, 类型typedef, struct  
- 头文件中函数的声明可以不带上extern, 但是变量的声明必须带上extern, 因为头文件最终是要展开到源文件中去的,源文件内可以定义和声明,那头文件也可以,如果头文件中变量声明不带extern,则无法区分该变量是声明还是定义(二义性).


#### 1.3.2 static













