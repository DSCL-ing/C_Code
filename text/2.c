//数据结构

//时间复杂度
//算法的时间复杂度是一个函数（数学里带有未知数的函数表达式）
//没办法计算具体时间，和环境，机器设备等有关
//算法的基本操作是执行次数，为算法的时间复杂度
//时间复杂度看的是主要的写或改写的次数，一些小的辅助计数器、记住下标忽略掉。（排序）


//实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数，只需要大概执行次数，那么这里我们使用大O的渐进表示法
//大O的渐进表示法：O（仅留下影响最大的项）
//如：F（N）= N^2+2*N+10 ，时间复杂度为O（N^2）
//推导大O阶方法：
//1、用常数1取代运行时间中的所有加法常数。即常数的执行次数的算法时间复杂度为1，估算O(1)
//如说优化算法到O(1),即把执行步骤优化到常数（无未知数）
//2、在修改后的运行次数函数中，只保留最高阶项。
//3、如果最高阶项存在且不是1，则去除与这个项目相乘的常数。得到的结果就是大O阶。
//常数，有限次的操作执行都当作1或忽略不计



//一般情况下时间复杂度计算时未知数都是用的N，但是也可以用M、K等等其他的

//时间复杂度做悲观预期，即最坏情况：只有惊喜，不能让老板失望
//平均情况基本上没什么意义，很少看平均，99%看最坏
//最坏情况：任意输入规模的最大运行次数(上界)   1次找到
//平均情况：任意输入规模的期望运行次数         N/2次找到
//最好情况：任意输入规模的最小运行次数(下界)   N次找到


//求折半查找binarysort算法时间复杂度
//方法一推演过程：逆向
//正向每次大小折半，逆向每次大小翻倍，设次数为x
//则正向有1*2*2*2*···*2=N(N为数组大小)
//即2^x=N   ， 两边取对数,即可得到时间复杂度为
//x = log2(N)

//方法二，正向，思想一样，N/2^x=1

//二分查找算法是一个非常牛逼的算法(纸老虎)
//N个数中查找            大概查找次数
//1000 =2^x              10       | 2^10=1024≈1000         
//100W =2^x              20		  | 2^20=2^10*2^10=1024*1024≈10w=10^6
//10亿 =2^x              30  	  | 10^9=1000*1000*1000≈2^30
//缺点是需要先排序

//以后要学习更牛逼的
//树->二叉树->搜索二叉树->平衡搜索二叉树->AVLTree RBTree   哈希表   B树系列

//递归算法:递归次数*每次递归内操作执行的次数
//斐波那契递归算法 O(2^N) 没有用的算法，太慢了



//_____________________________________________________________________________________
//_____________________________________________________________________________________
//空间复杂度(额外使用的空间，本来就有的不算，重复的不算)

//在运行过程中临时额外占用存储空间的大小的量度。
//空间复杂度算的是变量的个数，基本和时间复杂度一致，用大O渐进表示法
//递归中的栈帧也要算进去

//O(1)代表常数个，冒泡排序为O(1).	阶乘O（N），斐波那契数列递归O（N）
//空间可以重复利用：递归有规则，先递归一个到低，销毁空间，再递归第二个，用的最多次的就是空间复杂度。
//时间不能重复利用：执行多少是多少


//一道题有多种方法，不用全部实现，只需要分析出每种方法的复杂度，选复杂度优的方式即可，这就是时间复杂度在实际中的意义

//以时间换空间

//原地算法：不借助额外空间


//Online Judge：在线评委
//OJ分类
//1·IO型：写完整程序，测试用例由scanf，输出由printf
//2·接口型：按要求实现接口函数。
//_____________________________________________________________________________________
//_____________________________________________________________________________________
//_____________________________________________________________________________________
//OJ:复杂度
//面试题 17.04.消失的数字
//数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗
//https://leetcode-cn.com/problems/missing-number-lcci
//方法一：作差
//int missingNumber(int* nums, int numsSize){
//	int sum1 = 0;
//	int sum2 = 0;
//	sum2 = (0 + numsSize)*(numsSize + 1) / 2;
//	while (numsSize)
//	{
//		sum1 = sum1 + *nums++;
//		numsSize--;
//	}
//	return sum2 - sum1;
//}
//方法二：与0异或
//原理：相同数异或为0，0与任何数异或为其本身。
//所有数异或起来就会得到不成对的。由于相同异或后为0，下一组数即与0异或
//最终结果都是0与其他数异或，所以所有数异或不分顺序，
//一组先和0异或，再与另一组异或
//int missingNumber(int* nums, int numsSize){
//	int x = 0;
//	int i = 0;
//	for (i = 0; i <=numsSize; i++)
//	{
//		x ^=i;
//	}
//	for (i = 0; i < numsSize; i++)
//	{
//		x ^= nums[i];
//	}
//	return x;
//}

//OJ:旋转数组
//https://leetcode-cn.com/problems/rotate-array
//给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
//逆置原理：
//最左和最右互换 左加加右减减，直到左大于右。
/*
void Reverse(int *nums, int left, int right)
{
	int tmp = 0;
	while (left <= right)
	{
		tmp = nums[left];
		nums[left] = nums[right];
		nums[right] = tmp;
		left++;
		right--;
	}
}
void rotate(int* nums, int numsSize, int k)  //rotate   [ˈroʊteɪt]  旋转;轮转
{
	//意思是把最后一个数放到开头，持续k次
	if (k >= numsSize)
	{
		k %= numsSize;
	}
	Reverse(nums, 0, numsSize - k - 1);
	Reverse(nums, numsSize - k, numsSize - 1);
	Reverse(nums, 0, numsSize - 1);
}
*/

-------------------------------------------------------------------------- -
/*
树与二叉树

树：最常用的是孩子兄弟表示法（孩子链表）

基本上linux文件系统使用树，windows使用森林


二叉树
满二叉树第K层节点个数为2 ^ (K - 1)

高度为h的满二叉树的节点个数为2^h - 1

完全二叉树最多节点：2^h - 1;
		  最少节点：2^(h-1);


堆
//孩子与父亲下标关系
//leftchild = parent*2 + 1;
//rightchild = parent*2 + 2;

//int parent = (child-1)/2 


//孩子超出数组大小即不存在

//大根堆：根大于等于子节点

//小根堆：根小于等于子节点

//   1	       1
// 1   1	   2
//1 1 1 1      4
//...		   ..



TopK问题
假设N很大 ， k很小，比如N = 100亿 ， k =5.
100亿个整数，需要多少空间，1G = 1024*1024*1024 = 10亿byte
100亿个整数 = 400亿字节 = 40*10字节 = 40G

方法一:建立大小为N的大堆，依次Pop 
时间复杂度：N+logN*K
空间复杂度：1
缺点:放不进内存

方法2：建立一个大小为K的小堆。遍历外存中数据，如果比堆顶大就替换。最后，最大的K个数就在这个小堆里面

大的数会沉底，小的数在堆顶，只要比堆顶大的数就进去，最终堆中一定是最大K个

时间复杂度：K + （N-K)*logK   =  N*logK
空间复杂度：K
效率：并不是很快，但可以实现



二叉树的遍历（增删查改意义不大，作用不大）

管理思维/分治思想     假设每个领导最多管理两人，

二叉树的遍历有四种：
前序遍历 / 先根遍历：根->左子树->右子树
中序遍历 / 中根遍历：左子树->根->右子树
后续遍历 / 后根遍历：左子树->右子树->根
层序遍历：从第一层开始，每层从左到右，走完一层再到下一层


//			1
//	2				4
//3				5		6

前序：1 2 3 NULL NULL NULL 4 5 NULL NULL 6 NULL NULL
中序：NULL 3 NULL 2 NULL 1 NULL 5 NULL 4 6 NULL NULL
后续：NULL NULL 3 NULL 2 NULL NULL 5 NULL NULL 6 4
层序：1     2   4  3   5    6      

前、后序能确定根
中序能分割左右子树
故只有前、中序和中、后序才能确定一颗树





*/
-------------------------------------------------------------------------- -
/*
排序

排序基本上都是放数组中，效率

一、插入排序
1.直接插入
2.希尔排序
最坏情况：一组数据第一次要调整n/gap次，全部调好要1+2+3 ... + n/gap 、一共有gap组
总共：(1+2+3 ... + n/gap)*gap   ---- 最坏gap == 1      
->越小越慢，越大越块，因为求和的量级是二次


时间复杂度：O(n*n);












*/


























































//_____________________________________________________________________________________
//顺序表（Seqlist）：本质就是数组，但是在数组的基础上，还要求数据是连续存储，不能跳跃间隔。
//Seq顺序，list列表

#pragma once
#define N 1000  //静态顺序表
静态特点：容量有限，容易浪费；缺点：大小很难确定。

typedef int SLDataType;//类型重命名

typedef struct SeqList//顺序表
{
	SLDataType arr[N];
	int size;//数组当前容量
}SL;

//接口函数
void SeqListInit(SL*ps);                  //初始化
void SeqListPushBack(SL*ps, SLDataType x);//尾插
void SeqListPopBack(SL*ps);               //尾端删除元素
void SeqListPushFront(SL*ps, SLDataType x);//头部插入数据
void SeqListPopFront(SL*ps);               //头部删除数据
//...
//Push...插入，推入
//Pop...删除，弹出


//动态(主讲)
typedef struct SeqList//动态顺序表
{
	SLDataType *a;
	int size;//数组当前容量
	int capacity;//数组实际能存数据的空间容量
}SL;

//扩容适中倍速：2倍


//OJ题：双指针控制处理值增值减问题，多指针有灵活
//边界，内存系列


//-----------------------链表----------
//链表的分类
//实际中链表的结构非常多样，以下情况组合起来就有8种链表结构：
//1. 单向或者双向
//2. 带头或者不带头
//3. 循环或者非循环

//虽然有这么多的链表的结构，但是我们实际中最常用还是两种结构：
//1. 无头单向非循环链表:结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的
//子结构，如哈希桶、图的邻接表等等。另外这种结构在笔试面试中出现很多。
单链表缺点：尾删、插入、删除都要找前一个，O(N) ，低效
不用二级指针：带头

//2. 带头双向循环链表:结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构都是带头
//双向循环链表。另外这个结构虽然复杂，但是使用代码实现以后会发现此结构会带来很多优势，实现
//反而简单。



//---------------------顺序表和链表总结---------------------
//顺序表：
//优点：
//1·支持随机访问。需要随机访问结构支持的算法可以很好的适用。
//2·cpu高速缓存命中率更高
//缺点：
//1·头部中部插入删除时间效率低（删除）O(N)。
//2·物理空间连续，空间不够需要增容
//	a·增容有一定程度消耗
//	b·为了避免频繁增容，一般我们都按倍速去增，多了会造成空间浪费




//链表：
//优点：
//1·任意位置插入删除效率高。O(1)
//2·按需申请释放空间。
//缺点：
//1·不支持随机访问。意味着：一些排序，二分查找等在这种结构上不适用。
//2·链表存储一个值，同时要存储链接指针，也有一定的消耗。
//3·CPU高速缓存命中率更低。





//---------栈------------------
//栈：只能在一段进行插入和删除元素操作，是一种特殊的线性表。进行数据操作的一端称为栈顶，
//另一端称为栈底。栈中元素遵循LIFO(Last in First out)的原则。

//压栈:栈的插入操作就叫做进栈/压栈/入栈。
//出栈:栈的删除操作叫做出栈。

//出入数据都在栈顶进行
//弹夹中的子弹。

//栈就是一个结构体


//链式栈：
//双向->尾做栈顶
//单  ->头做栈顶 


//----------------队列---------------
//只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表。



//            --------------------------------------------------
//出队 Dequeue    <----                             <----        入队 Enqueue
//			  --------------------------------------------------  
//			         ↑                       ↑
//					队头                     队尾



//节点的度：子节点的个数，有多少个子节点。

//叶子节点/终端节点：度为零的节点（没有子节点的节点）。

//双亲节点/父节点：子节点的上一个
//孩子节点或子节点：节点的子节点

//兄弟节点（亲兄弟）：必须有相同父节点的节点才互称为兄弟节点

//树的度：度最大节点的度就是树的度

//节点的层次：从根（A）开始，根为第一层，根的子节点为第二层，以此类推。
//树的高度/深度：（最大的节点层次）最长的一条节点的个数。有一个节点为一层，有5个为5层

//节点的祖先：从根开始到该节点的所有节点都是该节点的祖先

//节点的子孙：下面都是


//-------------
//非终端节点/分支节点：度不为零的节点（非叶子节点） 
//森林等其他概念目前不常用


//树：
//1·树的子树是不相交的
//2·除了根节点，每个节点有且仅有只有一个父节点

//非树：（即）图

//特殊二叉树：(记高 度/层数为K)

//满二叉树：每一层都是满节点2^（K-1）, 所有节点数 N = 2^K-1 ，高度K = log2(N+1)

//完全二叉树:
//1·前 h-1 层都是满的
//2·最后一层不满，但是最后一层从左往右都是连续的
//3·度为1的节点最多为1,最少为0.(用于推断题)

//实际应用：搜索二叉树----------普通二叉树在实际应用中（增删查改等）意义不大，但是理论基础

普通树的意义
1·可以为后面学习复杂有用的平衡树做铺垫
2·考试，很多题都是普通二叉树

//搜索二叉树：任何一颗树，左子树都比根要小，右子树都比根要大
//查找一个树，最多查找高度次。时间复杂度 O(N)

//（了解：很难）
//引申：平衡二叉树-----极端情况下搜索二叉树只往一条链分布下去
//平衡二叉树：两边节点数据比较均匀
//分为AVL树、红黑树、B树（多叉搜索树）---与数据库原理有关

//（自学）线索化：考试用，校招不考，实际没人用。
//（项目课）哈夫曼：实际不会直接用，主要用在文件亚索



//二叉树的性质：
//1·若规定根节点的层数为1，则一颗非空二叉树的第i层上最多有2 ^ (i-1)个节点。
//2·若规定根节点的层数为1，则深度为h的二叉树的最大节点数为N = 2^h-1。
//3·对任意的二叉树都有,度为0的节点的个数n0比度为2的节点的个数n2多1个.即n0 = n2 + 1.(不好推导)
//4·深度由性质2估算得h ≈ log2(N)


//example:
//1·某二叉树由399个节点,其中有199个度为2的节点,则该二叉树中的叶子节点数为200.

//2·在具有2n个节点的完全二叉树中, 叶子节点数为n
//解:  
//n0+n1+n2 = 2n	-----1
//n0 = n2 + 1     -----2
//联立得
//2n0+n1-1 = 2n
//有完全二叉树性质(n1最多为1,最少为0)得
//n1 = 1 或 n1 = 0(舍去,n不能为小数)
//所以n0 = n.

//3·一颗完全二叉树的节点数为531个,那么这颗树的高度为10
法一:所有减去缺少的X = 531, 其中x的范围[0, 2 ^ (h-1)-1].然后估算,设h=11,10,9...一次代入判断
   带入2^h-1 - X = 531
法二 : 估算 利用性质4, h≈log2(N),而2^9 = 512 < 531 < 2^10.故高度为10